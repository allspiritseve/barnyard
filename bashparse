#!/bin/bash

bash_parse_arguments() {
    local error=$(printf %q "$1") context=$(printf %q "$2")
    shift 2

    declare -a argument_lookup
    declare -a argument_properties

    local regex short long kind variable default

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                regex='^([a-zA-Z0-9]?),([^@:#]*)([@:#]?)(=.*)?$'
                # TODO Eval arguments instead.
                [[ "$1" =~ $regex ]] || { echo bad_parameter_argument "$1"; return; }
                short=${BASH_REMATCH[1]} long=${BASH_REMATCH[2]} kind=${BASH_REMATCH[3]} variable= default="${BASH_REMATCH[4]}"
                [[ -z "$long" ]] && variable=o_$short || variable=o_$long
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { echo "$error $context boolean $(printf %q "$1")" && return; }
                            echo "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { echo "$error $context boolean $(printf %q "$1")" && return; }
                            echo "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { echo "$error $context integer $(printf %q "$1")" && return; }
                            echo "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            echo "declare -a $variable=( $(printf %q "${default:1}") )"
                            ;;
                        x@ )
                            { echo "$error $context no_defaults $(printf %q "$1")" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            echo "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            echo "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            echo "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            echo "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            echo "declare -a $variable"
                            ;;
                    esac
                fi
                argument_eval="kind=$kind variable=$variable"
                if [[ -n "$long" ]]; then
                    argument_lookup+=("--${long}")
                    argument_properties+=("$argument_eval")
                fi
                if [[ -n "$short" ]]; then
                    argument_lookup+=("-${short}")
                    argument_properties+=("$argument_eval")
                fi
                shift
                ;;
        esac
    done

    # TODO What does getopt think of `-`?
    declare -a args=( "$@" )
    local i=0 j arged flag
    while [[ $i -lt ${#args[@]} ]]
    do
        arged=1
        case "${args[$i]}" in
            -- )
                let i=i+1
                break
                ;;
            --* )
                regex='^(--[a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { echo "$error $context unknown $(printf %q "$1")"; return; }
                long="${BASH_REMATCH[1]}"
                if [[ -z "${BASH_REMATCH[2]}" ]]; then
                    let i=i+1
                else
                    arged=0
                    args[i]=${BASH_REMATCH[2]}
                fi
                flag="$long"
                for (( j=0; j<${#argument_lookup[@]}; j++ )); do
                    [[ ${argument_lookup[$j]} == "$long" ]] && break
                done
                if [[ $j -eq ${#argument_lookup[@]} ]]; then
                    echo "$error unknown $(printf %q "$long")"
                    break
                fi
                eval "${argument_properties[$j]}"
                if [[ $kind == toggle && "$long" =~ no- ]]; then
                    echo "$variable=0"
                fi
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag="$short"
                for (( j=0; j<${#argument_lookup[@]}; j++ )); do
                    [[ ${argument_lookup[$j]} == "$short" ]] && break
                done
                if [[ $j -eq ${#argument_lookup[@]} ]]; then
                    { echo "$error $context unknown $(printf %q "$short")"; return; }
                fi
                eval "${argument_properties[$j]}"
                case "$kind" in
                    array | value )
                        args[i]=${short:2}
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { echo "$error $context no_args $(printf %q "$flag")"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                echo "$variable=0"
                ;;
            count )
                echo "let $variable=$variable+1"
                ;;
            toggle )
                echo "[[ \$$variable -eq 0 ]] && $variable=1 || variable=0"
                ;;
            value )
                echo "$variable[0]=$(printf %q "${args[$i]}")"
                let i=i+1
                ;;
            array )
                echo "$variable[0]+=($(printf %q "${args[$i]}"))"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq ${#args[@]} ]] && echo "set --" || echo "set --$(printf ' %q' "${args[@]:$i}")"
}

main() {
    bash_parse_arguments argbend 'a b c' ",long:" "s,:" "a,array@" "v,value:" "f,flag" "d,default:=a default value" -- "$@"
}

main "$@"
