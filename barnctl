#!/bin/bash

case "$OSTYPE" in
    linux-gnu )
        os=ubuntu
        ;;
    darwin* )
        os=osx
        export PATH=/usr/local/opt/gnu-getopt/bin:$PATH
        ;;
esac

SCRIPT_DIR=$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)

function barnctl_command_bootstrap() {
    local o_help o_gpg o_github o_repository o_branch
    barnctl_parse_arguments bootstrap \
        "h,help" \
        "u,user:" \
        "g,gpg:" "G,github:" \
        "b,branch:" "r,repository:" \
        -- "$@"

    local server=${o_argv[0]}
    if [[ -n "$o_user" ]]; then
        server="$o_user@$server"
    fi

    local gpg_key=$(<"$o_gpg")

    local fingerprint=$( \
        echo "$gpg_key" | \
            gpg --with-colons --import-options show-only --import --fingerprint | \
            awk -F: '/^fpr/ { print $10; exit }' \
    )

    function _compile_script() {
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo 'GITHUB_KEY=$(< <(cat <<'"'"EOF"'"
        cat "$o_github"
        echo 'EOF'
        echo '))'
        echo ''
        cat "${SCRIPT_DIR}/bootstrap.bash"
    }

    # https://unix.stackexchange.com/a/414640
    _compile_script | ssh "$server" bash -s "$(printf " %q" "$o_repository" "$o_branch" "$gpg_key" "$fingerprint")"
}

function barnctl_command_prepare() {
    local o_user
    barnctl_parse_arguments bootstrap \
        "h,help" \
        "u,user:" \
        -- "$@"
    local server=${o_argv[0]}
    if [[ -n "$o_user" ]]; then
        server="$o_user@$server"
    fi
    cat "${SCRIPT_DIR}/prepare.bash" | ssh "$server" bash
}

function acrectl_string_resource() {
    awk '/^# ___ '$1' ___/{flag=1;next}/^# ___/{flag=0}flag' $0 | sed -E 's/^# ?//g'
}

function abend() {
    local resource=$1
    shift
    local message=$(acrectl_string_resource error_$resource)
    if [[ -z $message ]]; then
        echo "error:" "$resource" "$@" 1>&2
    else
        printf "error: ${message}\n" "$@" 1>&2
    fi
    exit 1
}

function barnctl_parse_arguments() {
    local usage=$1
    shift

    declare -a is_short
    declare -a is_arged
    declare -a is_long
    declare -a opt_long
    declare -a opt_short

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                local regex='([a-zA-Z0-9]?),([^:]*)(:?)'
                [[ $1 =~ $regex ]] || abend bad_parameter_argument "$1"
                local short=${BASH_REMATCH[1]} long=${BASH_REMATCH[2]} arged_2=${BASH_REMATCH[3]}
                local arged=1
                if [[ -n $arged_2 ]]; then
                    arged=0
                fi
                if [[ -n "$long" ]]; then
                    is_long+=("--${long}")
                    if [[ $arged -eq 0 ]]; then
                        is_arged+=("--${long}")
                        opt_long+=("${long}:")
                    else
                        opt_long+=("${long}")
                    fi
                else
                    is_long+=("--")
                fi
                if [[ -n "$short" ]]; then
                    is_short+=("-${short}")
                    if [[ $arged -eq 0 ]]; then
                        is_arged+=("-${short}")
                        opt_short+=("${short}:")
                    else
                        opt_short+=("${short}")
                    fi
                else
                    is_short+=("-")
                fi
                shift
                ;;
        esac
    done

    local parsed=$(getopt -a -n acrectl -o +"$(printf "%s" "${opt_short[@]}")" --long "$(IFS=,; echo "${opt_long[*]}")" -- "$@")
    if [[ $? != 0 ]]; then
        abend usage_$usage
    fi
    eval set -- "$parsed"

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            --help | -h)
                acrectl_usage $usage
                exit
                ;;
            *)
                local arged=1 variable
                if [[ " ${is_arged[@]} " == *" ${1} "* ]]; then
                    arged=0
                fi
                if [[ "${1:0:2}" == "--" ]]; then
                    variable="o_${1:2:${#1}}"
                else
                    local index=0
                    for (( index=0; index<=${#is_short[@]}; index++ )); do
                        [[ ${is_short[$index]} == $1 ]] && break
                    done
                    if [[ "${is_long[$index]}" != "--" ]]; then
                        local long=${is_long[$index]}
                        variable="o_${long:2:${#long}}"
                    else
                        variable="o_${1:1:${#1}}"
                    fi
                fi
                local value=
                shift
                if [[ $arged == 0 ]]; then
                    value=$1
                    shift
                else
                    value=0
                fi
                eval "$variable=\$value"
                ;;
        esac
    done

    o_argv=()
    while [[ $# -ne 0 ]]; do
        o_argv+=("$1")
        shift
    done
}

IFS=$'\n' read -d '' -r -a BARNCTL_COMMANDS < <( \
    sed -n 's/^function barnctl_command_\(.*\)() {$/\1/p' $0 \
)

function barnctl_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnctl_command_$func" "$@"
            break
        fi
    done
}

barnctl_parse_arguments root "a,alpha:" "h,help" -- "$@"
barnctl_next_command "" "${o_argv[@]}"
