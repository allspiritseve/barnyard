#!/usr/bin/env zsh

VERSION=0.1.0

SCRIPT_DIR=${${0:a}%/*}

zsh_parse_arguments() {
    local error=${${1:-}:q} context=${${2:-}:q}
    shift 2

    declare -A argument_properties

    local regex short long kind variable default

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                regex='^([a-zA-Z0-9]?),([^@:#]*)([@:#]?)(=.*)?$'
                [[ "$1" =~ $regex ]] || { print -R "error definition ${1:q}"; return; }
                short=${match[1]} long=${match[2]} kind=${match[3]} variable= default="${match[4]}"
                [[ -z "$long" ]] && variable=o_$short || variable=o_$long
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q})" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { print -R "$error $context integer ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable=( ${default:1:q} )"
                            ;;
                        x@ )
                            { print -R "$error $context no_defaults ${1:q}" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            print -R "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            print -R "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            print -R "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            print -R "declare -a $variable"
                            ;;
                    esac
                fi
                if [[ -n "$long" ]]; then
                    argument_properties["--${long}"]="kind=$kind variable=$variable"
                fi
                if [[ -n "$short" ]]; then
                    argument_properties["-${short}"]="kind=$kind variable=$variable"
                fi
                shift
                ;;
        esac
    done

    declare -a args=( "$@" )
    local i=1 arged flag
    while [[ $i -le ${#args[@]} ]]
    do
        case "${args[$i]}" in
            -- )
                let i=i+1
                break
                ;;
            --* )
                arged=1
                regex='^(--[a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { print -R "$error $context unknown ${1:q}"; return; }
                long="${match[1]}"
                if [[ "$match[2]" != '' ]]; then
                    arged=0
                    args[i]=${match[2]:1}
                else
                    let i=i+1
                fi
                flag=$long
                [[ -z "${argument_properties["$long"]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties["$long"]}"
                if [[ $kind == toggle && "$long" =~ no- ]]; then
                    print -R "$variable=0"
                fi
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag=$short
                [[ -z "${argument_properties["$short"]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties["$short"]}"
                case "$kind" in
                    array | value )
                        if [[ ${#short} -eq 2 ]]; then
                            let i=i+1
                        else
                            args[i]=${short:2}
                        fi
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { print -R "$error $context no_args ${flag:q}"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                print -R "$variable=0"
                ;;
            count )
                print -R "let $variable=$variable+1"
                ;;
            toggle )
                print -R "[[ \$$variable -eq 0 ]] && $variable=1 || variable=0"
                ;;
            value )
                print -R "${variable}[1]=${args[$i]:q}"
                let i=i+1
                ;;
            array )
                print -R "${variable}+=(${args[$i]:q})"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq $(( ${#args[@]} + 1 )) ]] && print -R "set --" || print -R "set -- ${(@)args[$i,-1]:q}"
}

acrectl_parse_arguments_error() {
    print -R -u 2 "@"
    exit 1
}

barnctl_parse_arguments() {
    zsh_parse_arguments barnctl_argument_error "$@"
    echo "[[ \$o_help -eq 0 ]] && usage_$1"
}

IFS=$'\n' read -d '' -r -A BARNCTL_COMMANDS < <( \
    sed -n 's/^barnctl_command_\(.*\)() {$/\1/p' "$SCRIPT_DIR/barnctl" \
)

barnctl_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnctl_command_$func" "$@"
            break
        fi
    done
}

barnctl_shell_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$SCRIPT_DIR/barnctl"
}

_barnctl_get_server() {
    local server="$1" user="$2"
    [[ -z "$user" ]] && print -R "$server"
    print -R "$user@$server"
}

barnctl_command_bootstrap() {
    eval "$(barnctl_parse_arguments bootstrap \
        "h,help" \
        "f,force" \
        "u,user:" \
        "p,fingerprint:" "G,github:" \
        "b,branch:" "r,repository:" \
        -- "$@")"

    local server="$(_barnctl_get_server "$@" "${o_user[1]}")"

#    local gpg_key=$(<"$o_gpg")

#    local fingerprint=$( \
#        echo "$gpg_key" | \
#            gpg --with-colons --import-options show-only --import --fingerprint | \
#            awk -F: '/^fpr/ { print $10; exit }' \
#    )

    _compile_script() {
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo 'GITHUB_KEY=$(< <(cat <<'"'"EOF"'"
        cat "$o_github"
        echo 'EOF'
        echo '))'
        barnctl_shell_resource barnctl_bootstrap
    }

    # https://unix.stackexchange.com/a/414640
    _compile_script | ssh "$server" bash -s "$(printf " %q" "$o_repository" "$o_branch" "$o_fingerprint" "$o_force")"
}

barnctl_command_update() {
    eval "$(barnctl_parse_arguments update "h,help" "u,user:" -- "$@")"

    _compile_script() {
        # TODO Why two forms of substitution?
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo ''
        barnctl_shell_resource barnctl_update
    }

    _compile_script | ssh "$(_barnctl_get_server "$@" "${o_user[1]}")" bash
}

barnctl_command_prepare() {
    eval "$(barnctl_parse_arguments prepare "h,help" "u,user:" -- "$@")"
    local server=${1:-}
    if [[ ${#o_user[@]} -ne 0 ]]; then
        server="${o_user[1]}@$server"
    fi
    barnctl_shell_resource barnctl_prepare | ssh "$server" bash
}

barnctl_command_run() {
    eval "$(barnctl_parse_arguments run "h,help" "u,user:" -- "$@")"
    ssh "$(_barnctl_get_server "$@" "${o_user[1]}")" sudo /usr/local/bin/barnyard
}

acrectl_string_resource() {
    awk '/^# ___ '$1' ___/{flag=1;next}/^# ___/{flag=0}flag' "$SCRIPT_DIR/barnctl" | sed -E 's/^# ?//g'
}

abend() {
    acrectl_quotedoc < /dev/stdin 1>&2
    exit 1
}

barnctl_quotedoc() {
    local heredoc spaces=65536 leading='^( +)([^[:space:]])' IFS='' dedented
    declare -a lines
    while read -r line; do
        lines+=("$line")
        if [[ "$line" =~ $leading ]]; then
            if [[ "${#BASH_REMATCH[1]}" -lt "$spaces" ]]; then
                spaces="${#BASH_REMATCH[1]}"
            fi
        else
            echo miss
        fi
    done < /dev/stdin
    read -r -d '' dedented < <(printf "%s\n" "${lines[@]}" | sed -E 's/^ {'$spaces'}//')
    eval "$({
        echo "cat <<EOF"
        echo -n "$dedented"
        echo "EOF"
    })"
}

barnctl_command_arguments() {
    barnctl_parse_arguments arguments ",long:" "s,:" "a,array@" "v,value:" "f,flag" -- "$@"
}

main() {
    eval "$(barnctl_parse_arguments root "h,help" -- "$@")"
    barnctl_next_command "" "$@"
}

main "$@"

exit

___ barnctl_prepare ___
cat <<'EOF' | sudo bash
echo '######### apt update ##########'
apt-get update && apt-get upgrade -y && apt-get -y autoremove
echo '######### install zsh, gnupg2, git ##########'
apt-get install -y zsh gnupg2 git
echo '######### check gpg ##########'
gpg --version
echo '######### check git ##########'
git --version
echo '######### install age ##########'
age_tar=$(curl -sL https://github.com/FiloSottile/age/releases/download/v1.0.0/age-v1.0.0-linux-amd64.tar.gz | base64)
echo "$age_tar" | base64 --decode | tar xz -O age/age > /usr/local/bin/age
chmod +x /usr/local/bin/age
echo "$age_tar" | base64 --decode | tar xz -O age/age-keygen > /usr/local/bin/age-keygen
chmod +x /usr/local/bin/age-keygen
echo '######### check age ##########'
age --version
echo '######### check age-keygen ##########'
age-keygen --version
echo '######### did this work? ##########'
gpg --list-keys
EOF
___ barnctl_bootstrap ___
abend() {
    local message=$1
    echo "$message" 1>&2
    exit 1
}

cat <<'EOF' | sudo bash -s "$@" || exit 1
set -e
set -o pipefail

force=$4

if [[ ( -e /etc/barnyard || -e /var/lib/barnyard ) && "$force" != 0 ]]; then
    echo "error: Barnyard already installed, use \`--force\` to overwrite." 1>&2
    exit 1
fi

rm -f /usr/local/bin/barnyard
rm -rf /etc/barnyard
rm -rf /var/barnyard/repository # legacy
rm -rf /var/lib/barnyard/repository
rm -rf /root/.ssh

mkdir -p /etc/barnyard
mkdir -p /var/lib/barnyard

while read -r key; do
    if [[ "$key" =~ ^pub: ]]; then
        IFS=':' read -r -a fields <<< "$key"
        gpg --yes --batch --delete-keys "${fields[4]}"
    fi
done < <(gpg --list-public-keys --with-colons)
EOF

echo "$GITHUB_KEY" | sudo bash -c 'umask 077; cat /dev/stdin > /etc/barnyard/id_barnyard'

cat <<'EOF' | sudo bash -s "$BARNYARD_SOURCE" "$@"
set -e
set -o pipefail

source="$1"
repository="$2"
branch="$3"
fingerprint="$4"

abend() {
    local message=$1
    echo "$message" 1>&2
    exit 1
}

cat <<EOC > /etc/barnyard/config
repository=$repository
branch=$branch
fingerprint=$fingerprint
EOC

mkdir -p /etc/barnyard
mkdir -p /var/lib/barnyard

umask 077
mkdir -p /root/.ssh
umask 022

known_github="github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg="
echo "$known_github" > /root/.ssh/known_hosts

GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes' \
    git clone -qb "$branch" "$repository" /var/lib/barnyard/repository 2> /dev/null

for key in $(find /var/lib/barnyard/repository/public_keys -name \*.asc); do
    gpg --import "$key" 2>/dev/null >/dev/null
done

echo "$source" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard

age-keygen -o /etc/barnyard/age 2>/dev/null
awk '/^# public key:/ { print $4 }' /etc/barnyard/age
EOF
___ barnctl_update ___
cat <<'EOF' | sudo bash -s "$BARNYARD_SOURCE"
source="$1"
if [[ -e /usr/local/bin/barnyard ]]; then
    if ! grep -q '^VERSION=' /usr/local/bin/barnyard; then
        version=0.0.0
    else
        version=$(grep '^VERSION=' /usr/local/bin/barnyard | sed 's/^VERSION=//')
    fi
    echo "######### old VERSION $version ##########"
    case "$version" in
        0.0.0 )
            echo "######### apt-get install -y zsh ##########"
            apt-get install -y zsh
            if [[ ! -d /var/lib/barnyard && -d /var/barnyard ]]; then
                echo "######### mv /var/barnyard /var/lib/barnyar ##########"
                mv /var/barnyard /var/lib/barnyard
            fi
            ;& # fall through
    esac
fi
rm -f /usr/local/bin/barnyard
echo "$source" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard
version=$(grep '^VERSION=' /usr/local/bin/barnyard | sed 's/^VERSION=//')
echo "######### new VERSION $version ##########"
EOF
___
