#!/usr/bin/env zsh

VERSION=0.6.10

SCRIPT_DIR=${${0:a}%/*}

___() {
}

zsh_parse_arguments() {
    local error=${${1:-}:q} context=${${2:-}:q}
    shift 2

    declare -A argument_properties

    local regex short long kind variable default pattern prefix=o_

    while :
    do
        case "$1" in
            -p | --prefix )
                prefix="$2"
                shift 2
                continue
                ;;
            -- )
                shift
                break
                ;;
            * )
                if [[ "$1" =~ ^([^,]+)=(.*)$ ]]; then
                    variable="$match[1]"
                    pattern="$match[2]"
                else
                    variable=
                    pattern="$1"
                fi
                regex='^([a-zA-Z0-9]?),([^@:#]*)([@:#]?)(=.*)?$'
                [[ "$pattern" =~ $regex ]] || { print -R "error definition ${1:q}"; return; }
                short=${match[1]} long=${match[2]} kind=${match[3]} default="${match[4]}"
                if [[ -z "$variable" ]]; then
                    [[ -z "$long" ]] && variable=$prefix$short || variable=$prefix${long//-/_}
                fi
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q})" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { print -R "$error $context integer ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable=( ${default:1:q} )"
                            ;;
                        x@ )
                            { print -R "$error $context no_defaults ${1:q}" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            print -R "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            print -R "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            print -R "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            print -R "declare -a $variable"
                            ;;
                    esac
                fi
                if [[ -n "$long" ]]; then
                    argument_properties[--${long}]="kind=$kind variable=$variable"
                fi
                if [[ -n "$short" ]]; then
                    argument_properties[-${short}]="kind=$kind variable=$variable"
                fi
                shift
                ;;
        esac
    done

    declare -a args=( "$@" )
    local i=1 arged flag
    while [[ $i -le ${#args[@]} ]]
    do
        case "${args[$i]}" in
            - )
                break
                ;;
            -- )
                let i=i+1
                break
                ;;
            --* )
                arged=1
                regex='^(--[-a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { print -R "$error $context unknown ${1:q}"; return; }
                long="${match[1]}"
                if [[ "$match[2]" != '' ]]; then
                    arged=0
                    args[i]=${match[2]:1}
                else
                    let i=i+1
                fi
                flag=$long
                [[ -z "${argument_properties[$long]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$long]}"
                if [[ $kind == toggle && "$long" =~ no- ]]; then
                    print -R "$variable=0"
                fi
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag=$short
                [[ -z "${argument_properties[$short]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$short]}"
                case "$kind" in
                    array | value )
                        if [[ ${#${args[$i]}} -eq 2 ]]; then
                            let i=i+1
                        else
                            args[i]=${${args[$i]}:2}
                        fi
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { print -R "$error $context no_args ${flag:q}"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                print -R "$variable=0"
                ;;
            count )
                print -R "let $variable=$variable+1"
                ;;
            toggle )
                print -R "[[ \$$variable -eq 0 ]] && $variable=1 || variable=0"
                ;;
            value )
                print -R "${variable}[1]=${args[$i]:q}"
                let i=i+1
                ;;
            array )
                print -R "${variable}+=(${args[$i]:q})"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq $(( ${#args[@]} + 1 )) ]] && print -R "set --" || print -R "set -- ${(@)args[$i,-1]:q}"
}

acrectl_parse_arguments_error() {
    print -R -u 2 "$@"
    exit 1
}

barnctl_parse_arguments() {
    zsh_parse_arguments barnctl_argument_error "$@"
    echo "[[ \$o_help -eq 0 ]] && usage_$1"
}

IFS=$'\n' read -d '' -r -A BARNCTL_COMMANDS < <( \
    sed -n 's/^barnctl_command_\(.*\)() {$/\1/p' "$SCRIPT_DIR/barnctl" \
)

barnctl_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnctl_command_$func" "$@"
            return
        fi
    done
    abend <<'    EOF'
        error: no such command \`barnctl ${prefix:gs/_/ }$command\`
    EOF
}

___ barnctl_common ___

barnctl_get_array() {
    [[ -n "${${(P)1}[$2]}" ]] && : ${(PA)3::=${(@Q)${(@z)${(P)1}[$2]}}}
}

barnctl_read_config_() {
    local file=${2:-} regex='^([^+=]+)(\+?=)(.*)$' line
    shift 2
    while [[ $# -ne 0 ]]; do
        barnctl_read_config[$1]=${2:-}
        shift 2
    done
    declare -a array
    while read -r line; do
        [[ "$line" =~ $regex ]] || abend bad_config "$config"
        local key=$match[1] element_type=$match[2] value=$match[3]
        case "$element_type" in
            += )
                if (( ${+barnctl_read_config[$key]} )); then
                    array=("${(@Q)${(@z)barnctl_read_config[$key]}}")
                else
                    array=()
                fi
                array+=("$value")
                barnctl_read_config[$key]="${(@qq)${array[@]}}"
                ;;
            = )
                barnctl_read_config[$key]="$value"
                ;;
        esac
    done < "$file"
}

barnctl_read_config() {
    [[ $(( $# % 2 )) == 0 ]] || abend bad_argument_count
    declare -A barnctl_read_config
    barnctl_read_config_ "$@"
    : ${(PA)${1:-reply}::=${(@kv)barnctl_read_config}}
}

barnctl_quotedoc() {
    local spaces=65536 leading='^( *)([^[:space:]])' IFS='' dedented
    declare -a lines
    while read -r line; do
        lines+=("$line")
        if [[ "$line" =~ $leading && "${#match[1]}" -lt "$spaces" ]]; then
            spaces="${#match[1]}"
        fi
    done < /dev/stdin
    read -r -d '' dedented < <(printf "%s\n" "${lines[@]}" | sed -E 's/^ {'$spaces'}//')
    eval "$({
        echo "cat <<EOF"
        echo -n "$dedented"
        echo "EOF"
    })"
}

abend() {
    barnctl_quotedoc < /dev/stdin 1>&2
    exit 1
}

warn() {
    barnctl_quotedoc < /dev/stdin 1>&2
}
___

barnctl_shell_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$SCRIPT_DIR/barnctl"
}

barnctl_command_always() {
    eval "$(barnctl_parse_arguments prepare "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    ssh "$server" "/usr/bin/sudo /usr/local/bin/barnyard always --version $VERSION"
}

barnctl_command_apply() {
    eval "$(barnctl_parse_arguments prepare "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    ssh "$server" "/usr/bin/sudo /usr/local/bin/barnyard apply --version $VERSION"
}

# For when you forget the SSH protocol. SSH will invoke a shell with the `-c`
# argument followed by a single command. If you want to pass arguments that
# single command would be something like `sh -c 'program hello,\ world'`. This
# is why we always generate a script and pipe to Bash. We know we get Bash and
# not an arbitray user shell and we don't have to do argument parser. We won't
# leak secrets by turning them into arguments for `ps` interception. Our
# server-side `barnyard` executable has commands to simplify  the construction
# of the scripts here.

barnctl_command_bootstrap() {
    eval "$(barnctl_parse_arguments bootstrap h,help g,gpg@ k,known: s,ssh: c,clone: -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    {
        if (( ${#o_known[@]} )); then
            print -R 'cat <<EOF | barnyard ssh known-hosts --version='$VERSION' - || exit 1'
            cat "$o_known[1]"
            print -R EOF
        fi
        if (( ${#o_ssh[@]} )); then
            print -R 'cat <<EOF | barnyard ssh private-key --version='$VERSION' - || exit 1'
            cat "$o_ssh[1]"
            print -R EOF
        fi
        for gpg in "${o_gpg[@]}"; do
            print -R 'cat <<EOF | barnyard gpg import --version='$VERSION' - || exit 1'
            cat "$gpg"
            print -R EOF
        done
        if (( ${#o_clone[@]} )); then
            print -R 'barnyard clone --version='$VERSION' '"${o_clone[@]:q} || exit 1"
        fi
    } | ssh "$server" '/usr/bin/sudo /bin/bash'
}

assert_barnyard_directory() {
    [[ -d age && -d users && -d machines && -d modules && -d resources ]] || abend<<'    EOF'
        error: barnyard utilties must be run in the barnyard directory
    EOF
}

barnctl_command_commit() {
    eval "$(barnctl_parse_arguments commit "h,help" -- "$@")"

    assert_barnyard_directory

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    ssh "$server" "/usr/local/bin/barnyard commit --version $VERSION"
}

barnctl_command_configure() {
    eval "$(barnctl_parse_arguments apply "h,help" "f,force" -- "$@")"
    local hostname=${1:-}
    shift
    [[ -d age && -d machines && -d modules ]] || abend<<'    EOF'
        error: barnyard utilties must be run in the barnyard directory
    EOF
    [[ -d "machines/$hostname" ]] || abend<<'    EOF'
        error: hostname configuration not found
    EOF
    declare -a modules
    if [[ $# -eq 0 ]]; then
        for module in machines/$hostname/*; do
            modules+=(${module##*/})
        done
    else
        modules=("$@")
    fi
    for module in "${modules[@]}"; do
        if [[ -e modules/$module/configure.zsh ]]; then
            zsh <(barnctl_shell_resource barnctl_configure) $SCRIPT_DIR $PWD $hostname $module $o_force || exit 1
        fi
    done
}

barnctl_command_generate() {
    eval "$(barnctl_parse_arguments generate "h,help" -- "$@")"

    assert_barnyard_directory

    local now=$(date +%s)

    declare -a file option
    declare -a tokens

    local line i j
    declare -a machine fields
    for configuration in "$@"; do
        [[ ${configuration#*.} != yaml ]] && continue
        tokens=(${(@Q)${(@z)"$(yq -o=json '.' < $configuration | jq  -r '
          [
              .machines | to_entries[] | .key as $machine | .value | to_entries as $a | $a | keys[] |
                  $machine, ., $a[.].key,
                      ($a[.].value | to_entries as $b | ($b | length), ($b[] | .key, (
                        .value as $v | ($v | if type == "array" then ($v | length), $v else (0, $v) end)
                        )))
          ] | flatten | @sh
        ')"}})
        let i=1
        while [[ $i -le ${#tokens[@]} ]]; do
            machine=${tokens[$i]}
            order=${tokens[(( i + 1 ))]}
            file=${tokens[(( i + 2 ))]}
            count=${tokens[(( i + 3 ))]}
            if [[ $order -eq 0 ]]; then
                rm -rf machines/$machine
                mkdir -p machines/$machine
                touch machines/$machine/.generated
            fi
            let i+=4
            print -R "_order=$order" > "machines/$machine/$file"
            while [[ $count -ne 0 ]]; do
                if (( $tokens[(( i + 1 ))] == 0 )); then
                    print -R "$tokens[i]=$tokens[(( i + 2 ))]" >> "machines/$machine/$file"
                    let i+=3
                else
                    j=0
                    while (( j != $tokens[(( i + 1 ))] )); do
                        print -R "$tokens[i]+=$tokens[(( i + j + 2 ))]" >> "machines/$machine/$file"
                        let j++
                    done
                    let i=i+2+j
                fi
                let count=count-1
            done
        done
    done

    local generate

    generate="$({
        barnctl_shell_resource barnctl_common
        print ''
        barnctl_shell_resource barnctl_generate
    })"

    for configuration in "$@"; do
        [[ ${configuration#*.} != zsh ]] && continue
        zsh -c "$generate" -- "$configuration" || exit 1
    done

    while read user; do
        rm -f "users/$user"
        touch "users/$user"
        while read line; do
            read -r -A option <<< "$line"
            local decoded=$(echo "${option[2]}" | base64 --decode)
            if [[ "$decoded" == *$'\n'* ]]; then
                echo "${option[1]}=${option[2]}" >> "users/$user"
            else
                echo "${option[1]}=${decoded}" >> "users/$user"
            fi
        done < <(gojq -r --yaml-input --arg user "${user}" '
            .users[$user] | to_entries[] | [ .key, (.value | tostring | @base64) ] | join(" ")
        ' < users.yaml)
    done < <(gojq -r --yaml-input '.users | to_entries[] | .key' < users.yaml)

    stat_format=(-c '%Y')
    [[ "$OSTYPE" = darwin* ]] && stat_format=(-f '%Dm')
    for machine in $(find . -name '.generated'); do
        if [[ $(stat "${stat_format[@]}" "$machine") -lt $now ]]; then
            rm -rf "$(dirname $machine)"
            rm -rf "resources/$(basename $(dirname $machine))"
            rm -f "age/$(basename $(dirname $machine))"
        fi
    done
}

barnctl_command_prepare() {
    eval "$(barnctl_parse_arguments prepare "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    {
        print -R 'BARNYARD_SOURCE=$(cat <<'"'"EOS"'"
        sed 's/VERSION=.*/VERSION='$VERSION'/' "${SCRIPT_DIR}/barnyard"
        print -R 'EOS'
        print -R ')'
        print -R ''
        barnctl_shell_resource barnctl_prepare
    } | ssh "$server" '/usr/bin/sudo /bin/bash'
}

barnctl_command_upgrade() {
    eval "$(barnctl_parse_arguments upgrade "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    {
        print -R 'BARNYARD_SOURCE=$(cat <<'"'"EOF"'"
        sed 's/VERSION=.*/VERSION='$VERSION'/' "${SCRIPT_DIR}/barnyard"
        print -R 'EOF'
        print -R ')'
        print -R ''
        print -R 'VERSION='$VERSION
        print -R ''
        barnctl_shell_resource barnctl_upgrade
    } | ssh "$server" '/usr/bin/sudo /bin/bash'
}

main() {
    eval "$(barnctl_parse_arguments root "h,help" -- "$@")"
    barnctl_next_command "" "$@"
}

barnctl_command_version() {
    eval "$(barnctl_parse_arguments version "h,help" -- "$@")"
    print -R "$VERSION"
}

main "$@"

exit

# Any keys specific to the machine permanent and are never updated. If a key
# specific to the machine is compromised, it means the machine is compromised,
# because the key never leaves the machine.

___ barnctl_prepare ___
barnyard_divider() {
    local label=${1:-}
    local bar=--------------------------------------------------------------------------------
    shift
    local prefix="------- $label "
    echo "$bar"
    echo "$prefix ${bar:0:$(( ${#bar} - ${#prefix} - 1 ))}"
    echo "$bar"
}
barnyard_divider 'apt update'
apt-get update && apt-get upgrade -y && apt-get -y autoremove
barnyard_divider 'install zsh, gnupg2, git'
apt-get install -y zsh gnupg2 git
barnyard_divider 'install barnyard'
echo "$BARNYARD_SOURCE" > /usr/local/bin/barnyard
chmod 755 /usr/local/bin/barnyard
barnyard version
barnyard prepare
___ barnctl_upgrade ___
if [[ -e /usr/local/bin/barnyard ]]; then
    if ! grep -q '^VERSION=' /usr/local/bin/barnyard; then
        version=0.0.0
    else
        version=$(grep '^VERSION=' /usr/local/bin/barnyard | sed 's/^VERSION=//')
    fi
else
    version=$VERSION
fi
rm -f /usr/local/bin/barnyard
echo "$BARNYARD_SOURCE" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard
echo "version: $version"
if [[ "$version" != "$VERSION" ]]; then
    case "$version" in
        0.0.0 )
            echo 'upgrade: 0.0.0 -> 0.1.0'
            apt-get install -y zsh
            if [[ ! -d /var/lib/barnyard && -d /var/barnyard ]]; then
                echo "######### mv /var/barnyard /var/lib/barnyar ##########"
                mv /var/barnyard /var/lib/barnyard
            fi
            version=0.1.0
            ;& # fall through
        * )
            echo "upgrade: $version -> $(barnyard version)"
            ;;
    esac
    echo "version: $(barnyard version)"
fi
___ barnctl_configure ___

source <(awk '/^___ barnctl_common ___/{flag=1;next}/^___/{flag=0}flag' "$1/barnctl")

shift

main() {
    declare -A o_barnyard o_module
    o_barnyard[barnyard]=${1:-} o_barnyard[hostname]=${2:-} o_barnyard[module]=${3:-} o_barnyard[force]=${4:-}
    shift 3
    o_barnyard[resources]="${o_barnyard[barnyard]}/resources/${o_barnyard[hostname]}"
    o_barnyard[age]=$(<"${o_barnyard[barnyard]}/age/${o_barnyard[hostname]}")
    barnctl_read_config o_module "${o_barnyard[barnyard]}/machines/${o_barnyard[hostname]}/${o_barnyard[module]}"
    source "${o_barnyard[barnyard]}/modules/${o_barnyard[module]}/configure.zsh"
}

main "$@"
___ barnctl_generate ___
@_args() {
    local key value
    typeset -A arguments arrays associative_arrays scalars seen
    typeset -a array remainder
    while (( $# != 0 )); do
        key="${1/%=*/=}"
        case "$1" in
            %* )
                key=${1#%}
                associative_arrays[$key]=0
                if (( ${+arguments[$key]} )); then
                    array=("${(@Q)${(@z)arguments[$key]}}")
                else
                    array=()
                fi
                array+=("${(@kv)${(P)key}}")
                arguments[$key]="${(@qq)${array[@]}}"
                ;;
            * )
                key="${1/%=*/=}"
                case "$key" in
                    *+= )
                        echo 'yes, hello'
                        key="${key%+=}"
                        value="${1#*=}"
                        arrays[$key]=0
                        if (( ${+arguments[$key]} )); then
                            array=("${(@Q)${(@z)arguments[$key]}}")
                        else
                            array=()
                        fi
                        array+=("$value")
                        arguments[$key]="${(@qq)${array[@]}}"
                        ;;
                    *= )
                        key="${key%=}"
                        value="${1#*=}"
                        scalars[$key]=0
                        arguments[$key]=${value:q}
                        ;;
                    * )
                        remainder+=("$1")
                        ;;
                esac
                ;;
        esac
        shift
    done
    local variable
    for variable in "${(@k)associative_arrays}"; do
        print -R "typeset -A $variable=($arguments[$variable])"
    done
    for variable in "${(@k)arrays}"; do
        print -R "typeset -a $variable=($arguments[$variable])"
    done
    for variable in "${(@k)scalars}"; do
        print -R "typeset $variable=$arguments[$variable]"
    done
    [[ 0 -eq ${#remainder[@]} ]] && print -R "set --" || print -R "set -- ${(@qq)remainder[@]}"
}

machine() {
    local hostname=${1:-}
    shift
    o_barnyard[hostname]="$hostname"
    __o_registers[order]=0
    rm -rf "machines/${hostname}"
    mkdir -p "machines/${hostname}"
    touch "machines/${hostname}/.generated"
}

@() {
    local module=${1:-}
    shift
    [[ -z "$module" ]] && abend<<'    EOF'
        error: module name is required
    EOF
    local regex='[a-z0-9_@]+'
    [[ "${module:1}" =~ $regex ]] || abend<<'    EOF'
        error: invalid module name $module
    EOF
    local filename key value
    filename="machines/${o_barnyard[hostname]}/$module"
    print -R "_order=$__o_registers[order]" > "$filename"
    while (( $# != 0 )); do
        if [[ -d "$1" ]]; then
            print -R "_module=${1#modules/}" >> "$filename"
            shift
            continue
        fi
        key="${1/#*=/=}"
        case "${1/%=*/=}" in
            once | diff | cron | never )
                print -R "_apply=$1" >> "$filename"
                ;;
            *@= )
                value="${1#*=}"
                if (( ${#${(@P)value}[@]} )); then
                    key="${1%%@=*}"
                    for value in "${(@P)value}"; do
                        print -R "$key+=$value" >> "$filename"
                    done
                fi
                ;;
            *+= | *\= )
                print -R "$1" >> "$filename"
                ;;
            %* )
                value="${1#%}"
                for key value in "${(@Pkv)value}"; do
                    print -R "$key=$value" >> "$filename"
                done
                ;;
            - )
                barnctl_quotedoc >> "$filename"
                ;;
            * )
                case "$1" in
                    %* )
                        for key value in "${@(kv){(P)${1#%}}}"; do
                            print -R "$key+=" >> "$filename"
                        done
                        ;;
                    * )
                        abend <<'                        EOF'
                            error: unknown module value $1"
                        EOF
                        ;;
                esac
                ;;
        esac
        shift
    done
    __o_registers[order]=$(( __o_registers[order] + 1 ))
}

main() {
    declare -A o_barnyard __o_registers
    o_barnyard[conifguration]=${1:-}
    shift
    source "$o_barnyard[conifguration]"
}

main "$@"
___
