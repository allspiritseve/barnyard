#!/bin/bash

VERSION=0.0.0

SCRIPT_DIR=$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)

barnctl_bash_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$SCRIPT_DIR/barnctl"
}

_barnctl_get_server() {
    local server="$1" user="$2"
    if [[ -z "$user" ]]; then
        echo "$server"
    fi
    echo "$user@$server"
}

barnctl_command_bootstrap() {
    eval "$(barnctl_parse_arguments bootstrap \
        "h,help" \
        "f,force" \
        "u,user:" \
        "p,fingerprint:" "G,github:" \
        "b,branch:" "r,repository:" \
        -- "$@")"

    local server=${1:-}
    if [[ ${#o_user[@]} -ne 0 ]]; then
        server="${o_user[0]}@$server"
    fi

#    local gpg_key=$(<"$o_gpg")

#    local fingerprint=$( \
#        echo "$gpg_key" | \
#            gpg --with-colons --import-options show-only --import --fingerprint | \
#            awk -F: '/^fpr/ { print $10; exit }' \
#    )

    _compile_script() {
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo 'GITHUB_KEY=$(< <(cat <<'"'"EOF"'"
        cat "$o_github"
        echo 'EOF'
        echo '))'
        echo ''
        barnctl_bash_resource barnctl_bootstrap
    }

    # https://unix.stackexchange.com/a/414640
    _compile_script | ssh "$server" bash -s "$(printf " %q" "$o_repository" "$o_branch" "$o_fingerprint" "$o_force")"
}

barnctl_command_update() {
    eval "$(barnctl_parse_arguments update "h,help" "u,user:" -- "$@")"

    local server=${1:-}
    if [[ ${#o_user[@]} -ne 0 ]]; then
        server="${o_user[0]}@$server"
    fi

    _compile_script() {
        # TODO Why two forms of substitution?
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo ''
        barnctl_bash_resource barnctl_update
    }

    _compile_script | ssh "$server" bash
}

barnctl_command_prepare() {
    eval "$(barnctl_parse_arguments prepare "h,help" "u,user:" -- "$@")"
    local server=${1:-}
    if [[ ${#o_user[@]} -ne 0 ]]; then
        server="${o_user[0]}@$server"
    fi
    barnctl_bash_resource barnctl_prepare | ssh "$server" bash
}

barnctl_command_run() {
    eval "$(barnctl_parse_arguments run "h,help" "u,user:" -- "$@")"
    ssh "$(_barnctl_get_server "$@" "${o_user[0]}")" sudo /usr/local/bin/barnyard
}

# TODO Outgoing.
barnctl_command_develop() {
    eval "$(barnctl_parse_arguments develop "h,help" -- "$@")"
    local directory
    [[ $# -ne 0 ]] || abend develop_directory_required
    directory=${o_argv[0]}
    [[ -d "$directory" ]] || abend develop_not_a_directory "$directory"
}

acrectl_string_resource() {
    awk '/^# ___ '$1' ___/{flag=1;next}/^# ___/{flag=0}flag' "$SCRIPT_DIR/barnctl" | sed -E 's/^# ?//g'
}

abend() {
    acrectl_quotedoc < /dev/stdin 1>&2
    exit 1
}

barnctl_quotedoc() {
    local heredoc spaces=65536 leading='^( +)([^[:space:]])' IFS='' dedented
    declare -a lines
    while read -r line; do
        lines+=("$line")
        if [[ "$line" =~ $leading ]]; then
            if [[ "${#BASH_REMATCH[1]}" -lt "$spaces" ]]; then
                spaces="${#BASH_REMATCH[1]}"
            fi
        else
            echo miss
        fi
    done < /dev/stdin
    read -r -d '' dedented < <(printf "%s\n" "${lines[@]}" | sed -E 's/^ {'$spaces'}//')
    eval "$({
        echo "cat <<EOF"
        echo -n "$dedented"
        echo "EOF"
    })"
}

barnctl_command_arguments() {
    barnctl_parse_arguments arguments ",long:" "s,:" "a,array@" "v,value:" "f,flag" -- "$@"
}

barnctl_argument_error() {
    echo "$@"
    exit 1
}

bash_parse_arguments() {
    local error=$(printf %q "$1") context=$(printf %q "$2")
    shift 2

    declare -a argument_lookup
    declare -a argument_properties

    local regex short long kind variable default

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                regex='^([a-zA-Z0-9]?),([^@:#]*)([@:#]?)(=.*)?$'
                # TODO Eval arguments instead.
                [[ "$1" =~ $regex ]] || { echo bad_parameter_argument "$1"; return; }
                short=${BASH_REMATCH[1]} long=${BASH_REMATCH[2]} kind=${BASH_REMATCH[3]} variable= default="${BASH_REMATCH[4]}"
                [[ -z "$long" ]] && variable=o_$short || variable=o_$long
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { echo "$error $context boolean $(printf %q "$1")" && return; }
                            echo "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { echo "$error $context boolean $(printf %q "$1")" && return; }
                            echo "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { echo "$error $context integer $(printf %q "$1")" && return; }
                            echo "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            echo "declare -a $variable=( $(printf %q "${default:1}") )"
                            ;;
                        x@ )
                            { echo "$error $context no_defaults $(printf %q "$1")" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            echo "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            echo "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            echo "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            echo "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            echo "declare -a $variable"
                            ;;
                    esac
                fi
                argument_eval="kind=$kind variable=$variable"
                if [[ -n "$long" ]]; then
                    argument_lookup+=("--${long}")
                    argument_properties+=("$argument_eval")
                fi
                if [[ -n "$short" ]]; then
                    argument_lookup+=("-${short}")
                    argument_properties+=("$argument_eval")
                fi
                shift
                ;;
        esac
    done

    # TODO What does getopt think of `-`?
    declare -a args=( "$@" )
    local i=0 j arged flag
    while [[ $i -lt ${#args[@]} ]]
    do
        arged=1
        case "${args[$i]}" in
            -- )
                let i=i+1
                break
                ;;
            --* )
                regex='^(--[a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { echo "$error $context unknown $(printf %q "$1")"; return; }
                long="${BASH_REMATCH[1]}"
                if [[ -z "${BASH_REMATCH[2]}" ]]; then
                    let i=i+1
                else
                    arged=0
                    args[i]=${BASH_REMATCH[2]}
                fi
                flag="$long"
                for (( j=0; j<${#argument_lookup[@]}; j++ )); do
                    [[ ${argument_lookup[$j]} == "$long" ]] && break
                done
                if [[ $j -eq ${#argument_lookup[@]} ]]; then
                    echo "$error unknown $(printf %q "$long")"
                    break
                fi
                eval "${argument_properties[$j]}"
                if [[ $kind == toggle && "$long" =~ no- ]]; then
                    echo "$variable=0"
                fi
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag="$short"
                for (( j=0; j<${#argument_lookup[@]}; j++ )); do
                    [[ ${argument_lookup[$j]} == "$short" ]] && break
                done
                if [[ $j -eq ${#argument_lookup[@]} ]]; then
                    { echo "$error $context unknown $(printf %q "$short")"; return; }
                fi
                eval "${argument_properties[$j]}"
                case "$kind" in
                    array | value )
                        args[i]=${short:2}
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { echo "$error $context no_args $(printf %q "$flag")"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                echo "$variable=0"
                ;;
            count )
                echo "let $variable=$variable+1"
                ;;
            toggle )
                echo "[[ \$$variable -eq 0 ]] && $variable=1 || variable=0"
                ;;
            value )
                echo "$variable[0]=$(printf %q "${args[$i]}")"
                let i=i+1
                ;;
            array )
                echo "$variable[0]+=($(printf %q "${args[$i]}"))"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq ${#args[@]} ]] && echo "set --" || echo "set --$(printf ' %q' "${args[@]:$i}")"
}

barnctl_parse_arguments() {
    bash_parse_arguments barnctl_argument_error "$@"
    echo "[[ \$o_help -eq 0 ]] && usage_$1"
}

IFS=$'\n' read -d '' -r -a BARNCTL_COMMANDS < <( \
    sed -n 's/^barnctl_command_\(.*\)() {$/\1/p' "$SCRIPT_DIR/barnctl" \
)

barnctl_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnctl_command_$func" "$@"
            break
        fi
    done
}

main() {
    eval "$(barnctl_parse_arguments root "h,help" -- "$@")"
    barnctl_next_command "" "$@"
}

main "$@"

exit

___ barnctl_prepare ___
cat <<'EOF' | sudo bash
echo '######### apt update ##########'
apt-get update && apt-get upgrade -y && apt-get -y autoremove
echo '######### install gnupg2, git ##########'
apt-get install -y gnupg2 git
echo '######### check gpg ##########'
gpg --version
echo '######### check git ##########'
git --version
echo '######### install age ##########'
age_tar=$(curl -sL https://github.com/FiloSottile/age/releases/download/v1.0.0/age-v1.0.0-linux-amd64.tar.gz | base64)
echo "$age_tar" | base64 --decode | tar xz -O age/age > /usr/local/bin/age
chmod +x /usr/local/bin/age
echo "$age_tar" | base64 --decode | tar xz -O age/age-keygen > /usr/local/bin/age-keygen
chmod +x /usr/local/bin/age-keygen
echo '######### check age ##########'
age --version
echo '######### check age-keygen ##########'
age-keygen --version
echo '######### did this work? ##########'
gpg --list-keys
EOF
___ barnctl_bootstrap ___
abend() {
    local message=$1
    echo "$message" 1>&2
    exit 1
}

cat <<'EOF' | sudo bash -s "$@" || exit 1
set -e
set -o pipefail

force=$4

if [[ ( -e /etc/barnyard || -e /var/barnyard ) && "$force" != 0 ]]; then
    echo "error: Barnyard already installed, use \`--force\` to overwrite." 1>&2
    exit 1
fi

rm -f /usr/local/bin/barnyard
rm -rf /etc/barnyard
rm -rf /var/barnyard/repository
rm -rf /root/.ssh

mkdir -p /etc/barnyard
mkdir -p /var/barnyard

while read -r key; do
    if [[ "$key" =~ ^pub: ]]; then
        IFS=':' read -r -a fields <<< "$key"
        gpg --yes --batch --delete-keys "${fields[4]}"
    fi
done < <(gpg --list-public-keys --with-colons)
EOF

echo "$GITHUB_KEY" | sudo bash -c 'umask 077; cat /dev/stdin > /etc/barnyard/id_barnyard'

cat <<'EOF' | sudo bash -s "$BARNYARD_SOURCE" "$@"
set -e
set -o pipefail

source="$1"
repository="$2"
branch="$3"
fingerprint="$4"

abend() {
    local message=$1
    echo "$message" 1>&2
    exit 1
}

cat <<EOC > /etc/barnyard/config
repository=$repository
branch=$branch
fingerprint=$fingerprint
EOC

mkdir -p /etc/barnyard
mkdir -p /var/barnyard

umask 077
mkdir -p /root/.ssh
umask 022

known_github="github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg="
echo "$known_github" > /root/.ssh/known_hosts

GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes' \
    git clone -qb "$branch" "$repository" /var/barnyard/repository 2> /dev/null

for key in $(find /var/barnyard/repository/public_keys -name \*.asc); do
    gpg --import "$key" 2>/dev/null >/dev/null
done

echo "$source" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard

age-keygen -o /etc/barnyard/age 2>/dev/null
awk '/^# public key:/ { print $4 }' /etc/barnyard/age
EOF
___ barnctl_update ___
cat <<'EOF' | sudo bash -s "$BARNYARD_SOURCE"
source="$1"
rm -f /usr/local/bin/barnyard
echo "$source" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard
EOF
___
