#!/bin/bash

case "$OSTYPE" in
    linux-gnu )
        os=ubuntu
        ;;
    darwin* )
        os=osx
        export PATH=/usr/local/opt/gnu-getopt/bin:$PATH
        ;;
esac

SCRIPT_DIR=$(cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd)

function barnctl_bash_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$SCRIPT_DIR/barnctl"
}

function _barnctl_get_server() {
    local server="$1" user="$2"
    if [[ -z "$user" ]]; then
        echo "$server"
    fi
    echo "$user@$server"
}

function barnctl_command_bootstrap() {
    local o_help o_fingerprint o_github o_repository o_branch o_user o_force=1
    barnctl_parse_arguments bootstrap \
        "h,help" \
        "u,user:" \
        "f,force" \
        "p,fingerprint:" "G,github:" \
        "b,branch:" "r,repository:" \
        -- "$@"

    local server=${o_argv[0]}
    if [[ -n "$o_user" ]]; then
        server="$o_user@$server"
    fi

#    local gpg_key=$(<"$o_gpg")

#    local fingerprint=$( \
#        echo "$gpg_key" | \
#            gpg --with-colons --import-options show-only --import --fingerprint | \
#            awk -F: '/^fpr/ { print $10; exit }' \
#    )

    function _compile_script() {
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo 'GITHUB_KEY=$(< <(cat <<'"'"EOF"'"
        cat "$o_github"
        echo 'EOF'
        echo '))'
        echo ''
        barnctl_bash_resource barnctl_bootstrap
    }

    # https://unix.stackexchange.com/a/414640
    _compile_script | ssh "$server" bash -s "$(printf " %q" "$o_repository" "$o_branch" "$o_fingerprint" "$o_force")"
}

function barnctl_command_update() {
    local o_help o_user
    barnctl_parse_arguments update "h,help" "u,user:" -- "$@"

    local server=${o_argv[0]}
    if [[ -n "$o_user" ]]; then
        server="$o_user@$server"
    fi

    function _compile_script() {
        # TODO Why two forms of substitution?
        echo 'BARNYARD_SOURCE=$(< <(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        echo 'EOF'
        echo '))'
        echo ''
        barnctl_bash_resource barnctl_update
    }

    _compile_script | ssh "$server" bash
}

function barnctl_command_prepare() {
    local o_user
    barnctl_parse_arguments prepare "h,help" "u,user:" -- "$@"
    local server=${o_argv[0]}
    if [[ -n "$o_user" ]]; then
        server="$o_user@$server"
    fi
    barnctl_bash_resource barnctl_prepare | ssh "$server" bash
}

function barnctl_command_run() {
    local o_user
    barnctl_parse_arguments run \
        "h,help" \
        "u,user:" \
        -- "$@"
    ssh "$(_barnctl_get_server "${o_argv[0]}" "$o_user")" sudo /usr/local/bin/barnyard
}

function barnctl_command_develop() {
    local o_help
    barnctl_parse_arguments develop "h,help" -- "$@"
    local directory
    [[ ${#o_argv[@]} -ne 0 ]] || abend develop_directory_required
    directory=${o_argv[0]}
    [[ -d "$directory" ]] || abend develop_not_a_directory "$directory"
}

function acrectl_string_resource() {
    awk '/^# ___ '$1' ___/{flag=1;next}/^# ___/{flag=0}flag' "$SCRIPT_DIR/barnctl" | sed -E 's/^# ?//g'
}

function abend() {
    local resource=$1
    shift
    local message=$(acrectl_string_resource error_$resource)
    if [[ -z $message ]]; then
        echo "error:" "$resource" "$@" 1>&2
    else
        printf "error: ${message}\n" "$@" 1>&2
    fi
    exit 1
}

function barnctl_parse_arguments() {
    local usage=$1
    shift

    declare -a is_short
    declare -a is_arged
    declare -a is_long
    declare -a opt_long
    declare -a opt_short

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                local regex='([a-zA-Z0-9]?),([^:]*)(:?)'
                [[ $1 =~ $regex ]] || abend bad_parameter_argument "$1"
                local short=${BASH_REMATCH[1]} long=${BASH_REMATCH[2]} arged_2=${BASH_REMATCH[3]}
                local arged=1
                if [[ -n $arged_2 ]]; then
                    arged=0
                fi
                if [[ -n "$long" ]]; then
                    is_long+=("--${long}")
                    if [[ $arged -eq 0 ]]; then
                        is_arged+=("--${long}")
                        opt_long+=("${long}:")
                    else
                        opt_long+=("${long}")
                    fi
                else
                    is_long+=("--")
                fi
                if [[ -n "$short" ]]; then
                    is_short+=("-${short}")
                    if [[ $arged -eq 0 ]]; then
                        is_arged+=("-${short}")
                        opt_short+=("${short}:")
                    else
                        opt_short+=("${short}")
                    fi
                else
                    is_short+=("-")
                fi
                shift
                ;;
        esac
    done

    local parsed=$(getopt -a -n acrectl -o +"$(printf "%s" "${opt_short[@]}")" --long "$(IFS=,; echo "${opt_long[*]}")" -- "$@")
    if [[ $? != 0 ]]; then
        abend usage_$usage
    fi
    eval set -- "$parsed"

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            --help | -h)
                acrectl_usage $usage
                exit
                ;;
            *)
                local arged=1 variable
                if [[ " ${is_arged[@]} " == *" ${1} "* ]]; then
                    arged=0
                fi
                if [[ "${1:0:2}" == "--" ]]; then
                    variable="o_${1:2:${#1}}"
                else
                    local index=0
                    for (( index=0; index<=${#is_short[@]}; index++ )); do
                        [[ ${is_short[$index]} == $1 ]] && break
                    done
                    if [[ "${is_long[$index]}" != "--" ]]; then
                        local long=${is_long[$index]}
                        variable="o_${long:2:${#long}}"
                    else
                        variable="o_${1:1:${#1}}"
                    fi
                fi
                local value=
                shift
                if [[ $arged == 0 ]]; then
                    value=$1
                    shift
                else
                    value=0
                fi
                eval "$variable=\$value"
                ;;
        esac
    done

    o_argv=()
    while [[ $# -ne 0 ]]; do
        o_argv+=("$1")
        shift
    done
}

IFS=$'\n' read -d '' -r -a BARNCTL_COMMANDS < <( \
    sed -n 's/^function barnctl_command_\(.*\)() {$/\1/p' "$SCRIPT_DIR/barnctl" \
)

function barnctl_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnctl_command_$func" "$@"
            break
        fi
    done
}

barnctl_parse_arguments root "a,alpha:" "h,help" -- "$@"
barnctl_next_command "" "${o_argv[@]}"

exit

___ barnctl_prepare ___
cat <<'EOF' | sudo bash
echo '######### apt update ##########'
apt-get update && apt-get upgrade -y && apt-get -y autoremove
echo '######### install gnupg2, git ##########'
apt-get install -y gnupg2 git
echo '######### check gpg ##########'
gpg --version
echo '######### check git ##########'
git --version
echo '######### install age ##########'
age_tar=$(curl -sL https://github.com/FiloSottile/age/releases/download/v1.0.0/age-v1.0.0-linux-amd64.tar.gz | base64)
echo "$age_tar" | base64 --decode | tar xz -O age/age > /usr/local/bin/age
chmod +x /usr/local/bin/age
echo "$age_tar" | base64 --decode | tar xz -O age/age-keygen > /usr/local/bin/age-keygen
chmod +x /usr/local/bin/age-keygen
echo '######### check age ##########'
age --version
echo '######### check age-keygen ##########'
age-keygen --version
echo '######### did this work? ##########'
gpg --list-keys
EOF
___ barnctl_bootstrap ___
function abend() {
    local message=$1
    echo "$message" 1>&2
    exit 1
}

cat <<'EOF' | sudo bash -s "$@" || exit 1
set -e
set -o pipefail

force=$4

if [[ ( -e /etc/barnyard || -e /var/barnyard ) && "$force" != 0 ]]; then
    echo "error: Barnyard already installed, use \`--force\` to overwrite." 1>&2
    exit 1
fi

rm -f /usr/local/bin/barnyard
rm -rf /etc/barnyard
rm -rf /var/barnyard/repository
rm -rf /root/.ssh

mkdir -p /etc/barnyard
mkdir -p /var/barnyard

while read -r key; do
    if [[ "$key" =~ ^pub: ]]; then
        IFS=':' read -r -a fields <<< "$key"
        gpg --yes --batch --delete-keys "${fields[4]}"
    fi
done < <(gpg --list-public-keys --with-colons)
EOF

echo "$GITHUB_KEY" | sudo bash -c 'umask 077; cat /dev/stdin > /etc/barnyard/id_barnyard'

cat <<'EOF' | sudo bash -s "$BARNYARD_SOURCE" "$@"
set -e
set -o pipefail

source="$1"
repository="$2"
branch="$3"
fingerprint="$4"

function abend() {
    local message=$1
    echo "$message" 1>&2
    exit 1
}

cat <<EOC > /etc/barnyard/config
repository=$repository
branch=$branch
fingerprint=$fingerprint
EOC

mkdir -p /etc/barnyard
mkdir -p /var/barnyard

umask 077
mkdir -p /root/.ssh
umask 022

known_github="github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg="
echo "$known_github" > /root/.ssh/known_hosts

GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes' \
    git clone -qb "$branch" "$repository" /var/barnyard/repository 2> /dev/null

for key in $(find /var/barnyard/repository/public_keys -name \*.asc); do
    gpg --import "$key" 2>/dev/null >/dev/null
done

echo "$source" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard

age-keygen -o /etc/barnyard/age 2>/dev/null
awk '/^# public key:/ { print $4 }' /etc/barnyard/age
EOF
___ barnctl_update ___
cat <<'EOF' | sudo bash -s "$BARNYARD_SOURCE"
source="$1"
rm -f /usr/local/bin/barnyard
echo "$source" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard
EOF
___
