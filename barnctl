#!/usr/bin/env zsh

BARNCTL_VERSION=0.1.0

SCRIPT_DIR=${${0:a}%/*}

___() {
}

zsh_parse_arguments() {
    local error=${${1:-}:q} context=${${2:-}:q}
    shift 2

    declare -A argument_properties

    local regex short long kind variable default

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                regex='^([a-zA-Z0-9]?),([^!@:#]*)([!@:#]?)(=.*)?$'
                [[ "$1" =~ $regex ]] || { print -R "error definition ${1:q}"; return; }
                short=${match[1]} long=${match[2]} kind=${match[3]} variable= default="${match[4]}"
                [[ -z "$long" ]] && variable=o_$short || variable=o_$long
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q})" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { print -R "$error $context integer ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable=( ${default:1:q} )"
                            ;;
                        x@ )
                            { print -R "$error $context no_defaults ${1:q}" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            print -R "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            print -R "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            print -R "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            print -R "declare -a $variable"
                            ;;
                    esac
                fi
                if [[ -n "$long" ]]; then
                    argument_properties[--${long}]="kind=$kind variable=$variable"
                fi
                if [[ -n "$short" ]]; then
                    argument_properties[-${short}]="kind=$kind variable=$variable"
                fi
                shift
                ;;
        esac
    done

    declare -a args=( "$@" )
    local i=1 arged flag
    while [[ $i -le ${#args[@]} ]]
    do
        case "${args[$i]}" in
            - )
                break
                ;;
            -- )
                let i=i+1
                break
                ;;
            --no-* )
                regex='^--no-([a-zA-Z0-9]+)$'
                if [[ "${args[$i]}" =~ $regex ]] && [[ -n "${argument_properties[--$match[1]]}" ]]; then
                    eval "${argument_properties[--$match[1]]}"
                    if [[ $kind == toggle ]]; then
                        args[$i]="--${match[1]}"
                        print -R "$variable=0"
                    fi
                fi
                echo "${argument_properties[--$match[1]]}"
                echo "${match[1]}"
                ;&
            --* )
                arged=1
                regex='^(--[a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { print -R "$error $context unknown ${1:q}"; return; }
                long="${match[1]}"
                if [[ "$match[2]" != '' ]]; then
                    arged=0
                    args[i]=${match[2]:1}
                else
                    let i=i+1
                fi
                flag=$long
                [[ -z "${argument_properties[$long]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$long]}"
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag=$short
                [[ -z "${argument_properties[$short]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$short]}"
                case "$kind" in
                    array | value )
                        if [[ ${#short} -eq 2 ]]; then
                            let i=i+1
                        else
                            args[i]=${short:2}
                        fi
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { print -R "$error $context no_args ${flag:q}"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                print -R "$variable=0"
                ;;
            count )
                print -R "let $variable=$variable+1"
                ;;
            toggle )
                print -R "[[ \$$variable -eq 0 ]] && $variable=1 || $variable=0"
                ;;
            value )
                print -R "${variable}[1]=${args[$i]:q}"
                let i=i+1
                ;;
            array )
                print -R "${variable}+=(${args[$i]:q})"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq $(( ${#args[@]} + 1 )) ]] && print -R "set --" || print -R "set -- ${(@)args[$i,-1]:q}"
}

acrectl_parse_arguments_error() {
    print -R -u 2 "$@"
    exit 1
}

barnctl_parse_arguments() {
    zsh_parse_arguments barnctl_argument_error "$@"
    echo "[[ \$o_help -eq 0 ]] && usage_$1"
}

IFS=$'\n' read -d '' -r -A BARNCTL_COMMANDS < <( \
    sed -n 's/^barnctl_command_\(.*\)() {$/\1/p' "$SCRIPT_DIR/barnctl" \
)

barnctl_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnctl_command_$func" "$@"
            return
        fi
    done
    abend <<'    EOF'
        error: no such command \`barnctl ${prefix:gs/_/ }$command\`
    EOF
}

___ barnctl_common ___

barnctl_read_config_() {
    local file=${2:-} regex='^([^=]+)=(.*)$' line
    shift 2
    while [[ $# -ne 0 ]]; do
        barnctl_read_config[$1]=${2:-}
        shift 2
    done
    while read -r line; do
        [[ "$line" =~ $regex ]] || abend bad_config "$config"
        local key=$match[1] value=$match[2]
        barnctl_read_config[$key]="$value"
    done < "$file"
}

barnctl_read_config() {
    [[ $(( $# % 2 )) == 0 ]] || abend bad_argument_count
    declare -A barnctl_read_config
    barnctl_read_config_ "$@"
    : ${(PA)${1:-reply}::=${(@kv)barnctl_read_config}}
}

barnctl_quotedoc() {
    local spaces=65536 leading='^( *)([^[:space:]])' IFS='' dedented
    declare -a lines
    while read -r line; do
        lines+=("$line")
        if [[ "$line" =~ $leading && "${#match[1]}" -lt "$spaces" ]]; then
            spaces="${#match[1]}"
        fi
    done < /dev/stdin
    read -r -d '' dedented < <(printf "%s\n" "${lines[@]}" | sed -E 's/^ {'$spaces'}//')
    eval "$({
        echo "cat <<EOF"
        echo -n "$dedented"
        echo "EOF"
    })"
}

abend() {
    barnctl_quotedoc < /dev/stdin 1>&2
    exit 1
}

warn() {
    barnctl_quotedoc < /dev/stdin 1>&2
}
___

barnctl_shell_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$SCRIPT_DIR/barnctl"
}

_barnctl_get_server() {
    local server="$1" user="$2"
    [[ -z "$user" ]] && print -R "$server"
    print -R "$user@$server"
}

# For when you forget the SSH protocol. SSH will invoke a shell with the `-c`
# argument followed by a single command. If you want to pass arguments that
# single command would be something like `sh -c 'program hello,\ world'`. This
# is why we always generate a script and pipe to Bash. We know we get Bash and
# not an arbitray user shell and we don't have to do argument parser. We won't
# leak secrets by turning them into arguments for `ps` interception. Our
# server-side `barnyard` executable has commands to simplify  the construction
# of the scripts here.

barnctl_command_bootstrap() {
    eval "$(barnctl_parse_arguments bootstrap h,help g,gpg@ k,known: s,ssh: c,clone: -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    barnctl_quotedoc<<'    EOF'
        known: ${o_known[1]}
        ssh: ${o_ssh[1]}
        gpg: ${o_gpg[@]}
        clone: ${o_clone[1]}
    EOF

    {
        if (( ${#o_known[@]} )); then
            print -R 'cat <<EOF | barnyard ssh known-hosts - || exit 1'
            cat "$o_known[1]"
            print -R EOF
        fi
        if (( ${#o_ssh[@]} )); then
            print -R 'cat <<EOF | barnyard ssh private-key - || exit 1'
            cat "$o_ssh[1]"
            print -R EOF
        fi
        for gpg in "${o_gpg[@]}"; do
            print -R 'cat <<EOF | barnyard gpg import - || exit 1'
            cat "$gpg"
            print -R EOF
        done
        if (( ${#o_clone[@]} )); then
            print -R 'barnyard clone '"${o_clone[@]:q} || exit 1"
        fi
    } | ssh "$server" '/usr/bin/sudo /bin/bash'
}

assert_barnyard_directory() {
    [[ -d age && -d users && -d machines && -d modules && -d resources ]] || abend<<'    EOF'
        error: barnyard utilties must be run in the barnyard directory
    EOF
}

barnctl_command_generate() {
    eval "$(barnctl_parse_arguments generate "h,help" -- "$@")"

    assert_barnyard_directory

    local now=$(date +%s)

    declare -a file option
    declare -a tokens

    local line i j
    declare -a machine fields
    for configuration in "$@"; do
        [[ ${configuration#*.} != yaml ]] && continue
        tokens=(${(@Q)${(@z)"$(yq -o=json '.' < $configuration | jq  -r '
          [
              .machines | to_entries[] | .key as $machine | .value | to_entries as $a | $a | keys[] |
                  $machine, ., $a[.].key,
                      ($a[.].value | to_entries as $b | ($b | length), ($b[] | .key, (
                        .value as $v | ($v | if type == "array" then ($v | length), $v else (0, $v) end)
                        )))
          ] | flatten | @sh
        ')"}})
        let i=1
        while [[ $i -le ${#tokens[@]} ]]; do
            machine=${tokens[$i]}
            order=${tokens[(( i + 1 ))]}
            file=${tokens[(( i + 2 ))]}
            count=${tokens[(( i + 3 ))]}
            if [[ $order -eq 0 ]]; then
                rm -rf machines/$machine
                mkdir -p machines/$machine
                touch machines/$machine/.generated
            fi
            let i+=4
            print -R "_order=$order" > "machines/$machine/$file"
            while [[ $count -ne 0 ]]; do
                if (( $tokens[(( i + 1 ))] == 0 )); then
                    print -R "$tokens[i]=$tokens[(( i + 2 ))]" >> "machines/$machine/$file"
                    let i+=3
                else
                    j=0
                    while (( j != $tokens[(( i + 1 ))] )); do
                        print -R "$tokens[i]+=$tokens[(( i + j + 2 ))]" >> "machines/$machine/$file"
                        let j++
                    done
                    let i=i+2+j
                fi
                let count=count-1
            done
        done
    done

    local generate

    generate="$({
        barnctl_shell_resource barnctl_common
        print ''
        barnctl_shell_resource barnctl_generate
    })"

    for configuration in "$@"; do
        [[ ${configuration#*.} != zsh ]] && continue
        zsh -c "$generate" -- "$configuration" || exit 1
    done

    while read user; do
        rm -f "users/$user"
        touch "users/$user"
        while read line; do
            read -r -A option <<< "$line"
            local decoded=$(echo "${option[2]}" | base64 --decode)
            if [[ "$decoded" == *$'\n'* ]]; then
                echo "${option[1]}=${option[2]}" >> "users/$user"
            else
                echo "${option[1]}=${decoded}" >> "users/$user"
            fi
        done < <(gojq -r --yaml-input --arg user "${user}" '
            .users[$user] | to_entries[] | [ .key, (.value | tostring | @base64) ] | join(" ")
        ' < users.yaml)
    done < <(gojq -r --yaml-input '.users | to_entries[] | .key' < users.yaml)

    stat_format=(-c '%Y')
    [[ "$OSTYPE" = darwin* ]] && stat_format=(-f '%Dm')
    for machine in $(find . -name '.generated'); do
        if [[ $(stat "${stat_format[@]}" "$machine") -lt $now ]]; then
            rm -rf "$(dirname $machine)"
            rm -rf "resources/$(basename $(dirname $machine))"
            rm -f "age/$(basename $(dirname $machine))"
        fi
    done
}

barnctl_command_commit() {
    eval "$(barnctl_parse_arguments commit "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    ssh "$server" '/usr/bin/sudo /bin/bash' << '    EOF'
        cd /var/lib/barnyard/commit && tar -czf - * | base64
    EOF
}

barnctl_command_update() {
    eval "$(barnctl_parse_arguments update "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    {
        print -R 'BARNYARD_SOURCE=$(cat <<'"'"EOF"'"
        cat "${SCRIPT_DIR}/barnyard"
        print -R 'EOF'
        print -R ')'
        print -R ''
        barnctl_shell_resource barnctl_update
    } | ssh "$server" '/usr/bin/sudo /bin/bash'
}

barnctl_command_prepare() {
    eval "$(barnctl_parse_arguments prepare "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    {
        print -R 'BARNYARD_SOURCE=$(cat <<'"'"EOS"'"
        cat "${SCRIPT_DIR}/barnyard"
        print -R 'EOS'
        print -R ')'
        print -R ''
        barnctl_shell_resource barnctl_prepare
    } | ssh "$server" '/usr/bin/sudo /bin/bash'
}

barnctl_command_configure() {
    eval "$(barnctl_parse_arguments apply "h,help" "f,force" -- "$@")"
    local hostname=${1:-}
    shift
    [[ -d age && -d machines && -d modules ]] || abend<<'    EOF'
        error: barnyard utilties must be run in the barnyard directory
    EOF
    [[ -d "machines/$hostname" ]] || abend<<'    EOF'
        error: hostname configuration not found
    EOF
    declare -a modules
    if [[ $# -eq 0 ]]; then
        for module in machines/$hostname/*; do
            modules+=(${module##*/})
        done
    else
        modules=("$@")
    fi
    for module in "${modules[@]}"; do
        if [[ -e modules/$module/configure.zsh ]]; then
            zsh <(barnctl_shell_resource barnctl_configure) $SCRIPT_DIR $PWD $hostname $module $o_force || exit 1
        fi
    done
}

barnctl_command_gpg_import() {
    eval "$(barnctl_parse_arguments gpg_import "u,user:" "h,help" -- "$@")"

    (( $# == 2 )) || abend <<'    EOF'
        error: a hostname and file name are required
    EOF

    local hostname=${1:-}
    shift

    local filename=${1:-} gpg_key
    shift
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi

    ssh "$(_barnctl_get_server "$hostname" "${o_user[1]}")" sudo /usr/local/bin/barnyard gpg import -
}

barnctl_command_gpg() {
    eval "$(barnctl_parse_arguments gpg "h,help" -- "$@")"
    barnctl_next_command gpg_ "$@"
}

barnctl_command_version() {
    eval "$(barnctl_parse_arguments version "h,help" -- "$@")"
    print -R $BARNCTL_VERSION
}

barnctl_command_apply() {
    eval "$(barnctl_parse_arguments prepare "h,help" -- "$@")"

    (( $# )) || abend<<'    EOF'
        erorr: ssh hostname is required
    EOF

    local server=${1:-}

    ssh "$server" '/usr/bin/sudo /usr/local/bin/barnyard apply'
}

acrectl_string_resource() {
    awk '/^# ___ '$1' ___/{flag=1;next}/^# ___/{flag=0}flag' "$SCRIPT_DIR/barnctl" | sed -E 's/^# ?//g'
}

barnctl_command_arguments() {
    barnctl_parse_arguments arguments ",long:" "s,:" "a,array@" "v,value:" "f,flag" -- "$@"
}

barnctl_command_quotedoc() {
    local greeting=hello
    barnctl_quotedoc <<'    EOF'
        hello

        $greeting

        hello
    EOF
local greeting=hello
barnctl_quotedoc <<EOF
hello

$greeting

hello
EOF
}

main() {
    eval "$(barnctl_parse_arguments root "h,help" -- "$@")"
    barnctl_next_command "" "$@"
}

main "$@"

exit

# Any keys specific to the machine permanent and are never updated. If a key
# specific to the machine is compromised, it means the machine is compromised,
# because the key never leaves the machine.

___ barnctl_prepare ___
echo '######### apt update ##########'
apt-get update && apt-get upgrade -y && apt-get -y autoremove
echo '######### install zsh, gnupg2, git ##########'
apt-get install -y zsh gnupg2 git
echo '######### check gpg ##########'
gpg --version
echo '######### check git ##########'
git --version
echo '######### install age ##########'
age_tar=$(curl -sL https://github.com/FiloSottile/age/releases/download/v1.0.0/age-v1.0.0-linux-amd64.tar.gz | base64)
echo "$age_tar" | base64 --decode | tar xz -O age/age > /usr/local/bin/age
chmod +x /usr/local/bin/age
echo "$age_tar" | base64 --decode | tar xz -O age/age-keygen > /usr/local/bin/age-keygen
chmod +x /usr/local/bin/age-keygen
age --version
echo '######### check age-keygen ##########'
age-keygen --version
echo '######### generate age key ##########'
mkdir -p /etc/barnyard
if [[ ! -e /etc/barnyard/age ]]; then
    age-keygen -o /etc/barnyard/age
fi
mkdir -p /var/lib/barnyard/commit/age
grep '^# public key: ' /etc/barnyard/age | sed 's/# public key: //' | tee /var/lib/barnyard/commit/age/$(hostname --long)
echo '######### generate root private key ##########'
( umask 077 && mkdir -p /etc/barnyard/gnupg )
export GNUPGHOME=/etc/barnyard/gnupg
key_details=$(cat <<EOD
    %echo Generating a basic OpenPGP key
    Key-Type: RSA
    Key-Length: 2048
    Subkey-Type: RSA
    Subkey-Length: 2048
    Name-Real: $(hostname --long)
    Name-Comment: Root Personal Key
    Name-Email: user@$(hostname --long)
    Expire-Date: 0
    %no-ask-passphrase
    %no-protection
    # Do a commit here, so that we can later print "done" :-)
    %commit
    %echo done
EOD
)
if ! gpg --list-keys $(hostname --long); then
    gpg --verbose --batch --gen-key <(echo "$key_details")
fi
gpg --list-keys
echo '######### install barnyard ##########'
echo "$BARNYARD_SOURCE" > /usr/local/bin/barnyard
chmod 755 /usr/local/bin/barnyard
barnyard version
___ barnctl_update ___
if [[ -e /usr/local/bin/barnyard ]]; then
    if ! grep -q '^VERSION=' /usr/local/bin/barnyard; then
        version=0.0.0
    else
        version=$(grep '^VERSION=' /usr/local/bin/barnyard | sed 's/^VERSION=//')
    fi
    echo "######### old VERSION $version ##########"
    case "$version" in
        0.0.0 )
            echo "######### apt-get install -y zsh ##########"
            apt-get install -y zsh
            if [[ ! -d /var/lib/barnyard && -d /var/barnyard ]]; then
                echo "######### mv /var/barnyard /var/lib/barnyar ##########"
                mv /var/barnyard /var/lib/barnyard
            fi
            ;& # fall through
    esac
fi
rm -f /usr/local/bin/barnyard
echo "$BARNYARD_SOURCE" > /usr/local/bin/barnyard
chmod +x /usr/local/bin/barnyard
version=$(grep '^VERSION=' /usr/local/bin/barnyard | sed 's/^VERSION=//')
echo "######### new VERSION $version ##########"
___ barnctl_configure ___

source <(awk '/^___ barnctl_common ___/{flag=1;next}/^___/{flag=0}flag' "$1/barnctl")

shift

main() {
    declare -A o_barnyard o_module
    o_barnyard[barnyard]=${1:-} o_barnyard[hostname]=${2:-} o_barnyard[module]=${3:-} o_barnyard[force]=${4:-}
    shift 3
    o_barnyard[resources]="${o_barnyard[barnyard]}/resources/${o_barnyard[hostname]}"
    o_barnyard[age]=$(<"${o_barnyard[barnyard]}/age/${o_barnyard[hostname]}")
    barnctl_read_config o_module "${o_barnyard[barnyard]}/machines/${o_barnyard[hostname]}/${o_barnyard[module]}"
    source "${o_barnyard[barnyard]}/modules/${o_barnyard[module]}/configure.zsh"
}

main "$@"
___ barnctl_generate ___
@_args() {
    local key value
    typeset -A arguments arrays associative_arrays scalars seen
    typeset -a array remainder
    while (( $# != 0 )); do
        key="${1/%=*/=}"
        case "$1" in
            %* )
                key=${1#%}
                associative_arrays[$key]=0
                if (( ${+arguments[$key]} )); then
                    array=("${(@Q)${(@z)arguments[$key]}}")
                else
                    array=()
                fi
                array+=("${(@kv)${(P)key}}")
                arguments[$key]="${(@qq)${array[@]}}"
                ;;
            * )
                key="${1/%=*/=}"
                case "$key" in
                    *+= )
                        key="${key%+=}"
                        value="${1#*=}"
                        arrays[$key]=0
                        if (( ${+arguments[$key]} )); then
                            array=("${(@Q)${(@z)arguments[$key]}}")
                        else
                            array=()
                        fi
                        array+=("$value")
                        arguments[$key]="${(@qq)${array[@]}}"
                        ;;
                    *= )
                        key="${key%=}"
                        value="${1#*=}"
                        scalars[$key]=0
                        arguments[$key]=${value:q}
                        ;;
                    * )
                        remainder+=("$1")
                        ;;
                esac
                ;;
        esac
        shift
    done
    local variable
    for variable in "${(@k)associative_arrays}"; do
        print -R "typeset -A $variable=($arguments[$variable])"
    done
    for variable in "${(@k)arrays}"; do
        print -R "typeset -a $variable=($arguments[$variable])"
    done
    for variable in "${(@k)scalars}"; do
        print -R "typeset $variable=$arguments[$variable]"
    done
    [[ 0 -eq ${#remainder[@]} ]] && print -R "set --" || print -R "set -- ${(@qq)remainder[@]}"
}

machine() {
    local hostname=${1:-}
    shift
    __o_registers[hostname]="$hostname"
    __o_registers[order]=0
    rm -rf "machines/${hostname}"
    mkdir -p "machines/${hostname}"
    touch "machines/${hostname}/.generated"
}

@() {
    local module=${1:-}
    shift
    [[ -z "$module" ]] && abend<<'    EOF'
        error: module name is required
    EOF
    local regex='[a-z0-9_@]+'
    [[ "${module:1}" =~ $regex ]] || abend<<'    EOF'
        error: invalid module name $module
    EOF
    local filename key value
    filename="machines/${__o_registers[hostname]}/$module"
    print -R "_order=$__o_registers[order]" > "$filename"
    while (( $# != 0 )); do
        if [[ -d "$1" ]]; then
            print -R "_module=${1#modules/}" >> "$filename"
            shift
            continue
        fi
        key="${1/#*=/=}"
        case "${1/%=*/=}" in
            once | diff | cron | never )
                print -R "_apply=$1" >> "$filename"
                ;;
            *@= )
                value="${1#*=}"
                key="${1%%@=*}"
                for value in "${(@P)value}"; do
                    print -R "$key+=$value" >> "$filename"
                done
                ;;
            *+= | *\= )
                print -R "$1" >> "$filename"
                ;;
            %* )
                value="${1#%}"
                for key value in "${(@Pkv)value}"; do
                    print -R "$key=$value" >> "$filename"
                done
                ;;
            - )
                barnctl_quotedoc >> "$filename"
                ;;
            * )
                case "$1" in
                    %* )
                        for key value in "${@(kv){(P)${1#%}}}"; do
                            print -R "$key+=" >> "$filename"
                        done
                        ;;
                    * )
                        abend <<'                        EOF'
                            error: unknown module value $1"
                        EOF
                        ;;
                esac
                ;;
        esac
        shift
    done
    __o_registers[order]=$(( __o_registers[order] + 1 ))
}

main() {
    declare -A o_barnyard __o_registers
    o_barnyard[conifguration]=${1:-}
    shift
    source "$o_barnyard[conifguration]"
}

main "$@"
___
