#!/usr/bin/env zsh

# Now I want the ability to export the barnyard functions.
#
# This means `barnyard apply`, `barnyard funcs`, `barnyard whever`.
#
# But we don't want to get into serious argument parsing, do we?

___() {
}

# TODO Cannot remember all that I wanted to do with property names, but it seems
# like all I need are the directives and based64 encoding. Maybe include is
# something like `@/modules/postgresql/common`.
SCRIPT_DIR=${${0:a}%/*}

VERSION=$(zsh $SCRIPT_DIR/barnctl version)

zsh_parse_arguments() {
    local error=${${1:-}:q} context=${${2:-}:q}
    shift 2

    declare -A argument_properties

    local regex short long kind variable default

    while :
    do
        case "$1" in
            --)
                shift
                break
                ;;
            *)
                regex='^([a-zA-Z0-9]?),([^!@:#]*)([!@:#]?)(=.*)?$'
                [[ "$1" =~ $regex ]] || { print -R "error definition ${1:q}"; return; }
                short=${match[1]} long=${match[2]} kind=${match[3]} variable= default="${match[4]}"
                [[ -z "$long" ]] && variable=o_$short || variable=o_$long
                if [[ "$default" != '' ]]; then
                    case x"$kind" in
                        x )
                            kind=flag
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\! )
                            kind=toggle
                            [[ "${default:1}" =~ ^[0-1]$ ]] || { print -R "$error $context boolean ${1:q})" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x\# )
                            kind=count
                            [[ "${default:1}" =~ ^-?[0-9]+$ ]] || { print -R "$error $context integer ${1:q}" && return; }
                            print -R "local $variable=${default:1}"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable=( ${default:1:q} )"
                            ;;
                        x@ )
                            { print -R "$error $context no_defaults ${1:q}" && return; }
                            ;;
                    esac
                else
                    case x"$kind" in
                        x )
                            kind=flag
                            print -R "local $variable=1"
                            ;;
                        x\! )
                            kind=toggle
                            print -R "local $variable=0"
                            ;;
                        x\# )
                            kind=count
                            print -R "local $variable=0"
                            ;;
                        x: )
                            kind=value
                            print -R "declare -a $variable"
                            ;;
                        x@ )
                            kind=array
                            print -R "declare -a $variable"
                            ;;
                    esac
                fi
                if [[ -n "$long" ]]; then
                    argument_properties[--${long}]="kind=$kind variable=$variable"
                fi
                if [[ -n "$short" ]]; then
                    argument_properties[-${short}]="kind=$kind variable=$variable"
                fi
                shift
                ;;
        esac
    done

    declare -a args=( "$@" )
    local i=1 arged flag
    while [[ $i -le ${#args[@]} ]]
    do
        case "${args[$i]}" in
            - )
                break
                ;;
            -- )
                let i=i+1
                break
                ;;
            --no-* )
                regex='^--no-([a-zA-Z0-9]+)$'
                if [[ "${args[$i]}" =~ $regex ]] && [[ -n "${argument_properties[--$match[1]]}" ]]; then
                    eval "${argument_properties[--$match[1]]}"
                    if [[ $kind == toggle ]]; then
                        args[$i]="--${match[1]}"
                        print -R "$variable=0"
                    fi
                fi
                echo "${argument_properties[--$match[1]]}"
                echo "${match[1]}"
                ;&
            --* )
                arged=1
                regex='^(--[a-zA-Z0-9]*)(=.*)?$'
                [[ "${args[$i]}" =~ $regex ]] || { print -R "$error $context unknown ${1:q}"; return; }
                long="${match[1]}"
                if [[ "$match[2]" != '' ]]; then
                    arged=0
                    args[i]=${match[2]:1}
                else
                    let i=i+1
                fi
                flag=$long
                [[ -z "${argument_properties[$long]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$long]}"
                ;;
            -* )
                short="${args[$i]}"
                short="${short:0:2}"
                flag=$short
                [[ -z "${argument_properties[$short]}" ]] && { print -R "$error $context unknown ${short:q}"; return; }
                eval "${argument_properties[$short]}"
                case "$kind" in
                    array | value )
                        if [[ ${#short} -eq 2 ]]; then
                            let i=i+1
                        else
                            args[i]=${short:2}
                        fi
                        ;;
                    * )
                        # TODO If you have args a b and c and you get -abd what
                        # does getopt do? Seems to just append...
                        if [[ ${#args[i]} -gt 2 ]]; then
                            args[i]="-${short:2}"
                        else
                            let i=i+1
                        fi
                        ;;
                esac
                ;;
            *)
                break
                ;;
        esac
        case "$kind" in
            flag | count | toggle )
                [[ $arged -eq 0 ]] && { print -R "$error $context no_args ${flag:q}"; return; }
                ;;
        esac
        case "$kind" in
            flag )
                print -R "$variable=0"
                ;;
            count )
                print -R "let $variable=$variable+1"
                ;;
            toggle )
                print -R "[[ \$$variable -eq 0 ]] && $variable=1 || $variable=0"
                ;;
            value )
                print -R "${variable}[1]=${args[$i]:q}"
                let i=i+1
                ;;
            array )
                print -R "${variable}+=(${args[$i]:q})"
                let i=i+1
                ;;
        esac
    done

    [[ $i -eq $(( ${#args[@]} + 1 )) ]] && print -R "set --" || print -R "set -- ${(@)args[$i,-1]:q}"
}

barnyard_argument_error() {
    print -R -u 2 "$@"
    exit 1
}

barnyard_parse_arguments() {
    zsh_parse_arguments barnyard_argument_error "$@"
    echo "[[ \$o_help -eq 0 ]] && usage_$1"
}

IFS=$'\n' read -d '' -r -A BARNCTL_COMMANDS < <( \
    sed -n 's/^barnyard_command_\(.*\)() {$/\1/p' "$SCRIPT_DIR/barnyard" \
)

barnyard_next_command() {
    local prefix=$1 command=$2
    shift 2
    for func in "${BARNCTL_COMMANDS[@]}"; do
        if [[ "$func" == "$prefix$command" ]]; then
            "barnyard_command_$func" "$@"
            return
        fi
    done
    abend <<'    EOF'
        error: no such command \`barnyard ${prefix:gs/_/ }$command\`
    EOF
}

barnyard_cleanup() {
    [[ -n "$BARNYARD_TEMP" ]] && rm -rf "$BARNYARD_TEMP"
}

barnyard_temporary_directory() {
    [[ -n "$BARNYARD_TEMP" ]] && return
    BARNYARD_TEMP="$(mktemp -d)"
    export BARNYARD_TEMP
}

trap barnyard_cleanup EXIT

___ barnyard_common ___

__barnyard_priorities() {
    local func=${1:-exit}

    shift


    declare -A PRIORITY

    PRIORITY[panic]=0
    PRIORITY[alert]=1
    PRIORITY[crit]=2
    PRIORITY[err]=3
    PRIORITY[warn]=4
    PRIORITY[notice]=5
    PRIORITY[info]=6
    PRIORITY[debug]=7

    if [[ -n "$BARNYARD_LOG_LEVEL" ]]; then
        [[ -z "${PRIORITY[$BARNYARD_LOG_LEVEL]}" ]] && abend "invalid log level %s" "$BARNYARD_LOG_LEVEL"
    else
        BARNYARD_LOG_LEVEL=info
    fi

    # An environment variable so someone can set this in their shell.
    export BARNYARD_LOG_LEVEL

    "$func" "$@"
}

barnyard_bash_resource() {
    awk '/^___ '$1' ___/{flag=1;next}/^___/{flag=0}flag' "$SCRIPT_DIR/barnyard"
}

barnyard_write_config() {
    local map=${1:-} file=${2:-}
    declare -a fields
    for key value in "${(@kv)${(P)map}}"; do
        fields+=("${key}=${value}")
    done
    print "${(j:\n:)fields}" > "$file"
}

barnyard_read_config_() {
    local file=${2:-} regex='^([^+=]+)(\+?=)(.*)$' line
    shift 2
    while [[ $# -ne 0 ]]; do
        barnyard_read_config[$1]=${2:-}
        shift 2
    done
    declare -a array
    while read -r line; do
        [[ "$line" =~ $regex ]] || abend bad_config "$config"
        local key=$match[1] element_type=$match[2] value=$match[3]
        case "$element_type" in
            += )
                if (( ${+barnyard_read_config[$key]} )); then
                    array=("${(@Q)${(@z)barnyard_read_config[$key]}}")
                else
                    array=()
                fi
                array+=("$value")
                barnyard_read_config[$key]="${(@qq)${array[@]}}"
                ;;
            = )
                barnyard_read_config[$key]="$value"
                ;;
        esac
    done < "$file"
}

barnyard_get_array() {
    [[ -n "${${(P)1}[$2]}" ]] && : ${(PA)3::=${(@Q)${(@z)${(P)1}[$2]}}}
}

barnyard_read_config() {
    [[ $(( $# % 2 )) == 0 ]] || abend bad_argument_count
    declare -A barnyard_read_config
    barnyard_read_config_ "$@"
    : ${(PA)${1:-reply}::=${(@kv)barnyard_read_config}}
}

barnyard_parse_arguments_() {
    shift
    local regex='^([^=]+)=(.*)$'
    while [[ $# -ne 0 ]]; do
        [[ "$1" =~ $regex ]] || abend bad_argument "$1"
        shift
        barnyard_parse_arguments+=("$match[1]" "$match[2]")
    done
}

__barnyard_parse_arguments() {
    declare -a barnyard_parse_arguments
    barnyard_parse_arguments_ "$@"
    : ${(PA)${1:-reply}::=${(@kv)barnyard_parse_arguments}}
}

abend() {
    log priority=err "$@"
    exit 1
}

log() {
    SALT=a5bbeb04f50fcdee70b0b5976438a8d8

    local priority level
    if [[ -z "${PRIORITY[$1]-}" ]]; then
        priority=info
    else
        priority="$1"
        shift
    fi


    declare -a journald syslog
    local name value regex='^([^=]+)=(.*)$'
    while true; do
        if [[ "$1" =~ $regex ]]; then
            name="${match[1]}" value="${match[2]}"
            journald+=("${name:u}=${value}")
            syslog+=("${name}=${value}")
            if [[ "$name" == priority ]]; then
                priority=$value
            fi
            shift
        else
            break
        fi
    done

    if [[ -n "${o_barnyard[module]}" ]]; then
        journald+=("MODULE=${o_barnyard[module]}")
        syslog+=("module=${o_barnyard[module]}")
    fi

    level=$PRIORITY[$priority]

    if (set +u; [[ "$priority" -gt "${PRIORITY[$BARNYARD_LOG_LEVEL]}" ]]); then
        return
    fi

    local format="$1" message
    shift
    message=$(printf "$format\n" "$@")

    local context=''
    if [[ ${#syslog[@]} -ne 0 ]]; then
        context="; ${(j:, :)syslog}"
    fi

    print -R "$(date --rfc-3339=s | sed 's/+.*//') barnyard[$priority]: $message$context"

    local id
    id=$(print -R "$SALT" "$format" | md5sum | cut -d' ' -f1)

    journald+=("MESSAGE_ID=$id" "MESSAGE=$message" PRIORITY=$level SYSLOG_FACILITY=1)
    print "${(j:\n:)journald}" | logger --journald
}

barnyard_divider() {
    local label="$1"
    local bar=--------------------------------------------------------------------------------
    shift
    local prefix="------- $label "
    echo "$bar"
    echo "$prefix ${bar:0:$(( ${#bar} - ${#prefix} - 1 ))}"
    echo "$bar"
}

barnyard_quotedoc() {
    local heredoc spaces=65536 leading='^( *)([^[:space:]])' IFS='' dedented
    declare -a lines
    while read -r line; do
        lines+=("$line")
        if [[ "$line" =~ $leading ]]; then
            if [[ "${#match[1]}" -lt "$spaces" ]]; then
                spaces="${#match[1]}"
            fi
        fi
    done < /dev/stdin
    read -r -d '' dedented < <(printf "%s\n" "${lines[@]}" | sed -E 's/^ {'$spaces'}//')
    eval "$({
        print -R "cat <<EOF"
        print -R -n "$dedented"
        print -R "EOF"
    })"
}

___
barnyard_command_functions() {
    eval "$(barnyard_parse_arguments functions "h,help" -- "$@")"
    awk '/^___ barnyard_common ___/{flag=1;next}/^___/{flag=0}flag' "$1"
}

barnyard_clone() {
    local directory="$BARNYARD_TEMP/$1"
    mkdir -p "$directory"
    if [[ "$o_barnyard[stage]" == production ]]; then
        git -C "$o_registers[barnyard]" archive "${o_barnyard[checkout]}" | tar -C "$directory" -x
    else
        cp -R "$o_registers[barnyard]"/* "$directory"
    fi
}

barnyard_clone_directory() {
    barnyard_temporary_directory

    mkdir -p "$BARNYARD_TEMP/barnyard"
    mkdir -p "$BARNYARD_TEMP/modules"

    barnyard_bash_resource barnyard_run > "$BARNYARD_TEMP/run"
}

barnyard_run() {
    local module

    module=${1:-}

    shift

    barnyard_clone "runs/$module"

    o_barnyard[barnyard]="$BARNYARD_TEMP/runs/$module"
    o_barnyard[configuration]="$o_barnyard[barnyard]/machines/$o_barnyard[hostname]/$module"
    o_barnyard[resources]="$o_barnyard[barnyard]/resources/$o_barnyard[hostname]"
    o_barnyard[age]="$(<"$o_barnyard[barnyard]/age/$o_barnyard[hostname]")" || \
        abend module=$module hostname="$o_barnyard[hostname]" 'age key missing for $%s' "$o_barnyard[hostname]"

    typeset -A o_module

    [[ -e "$o_barnyard[configuration]" ]] || abend 'no configuration for module %s' "$module"
    barnyard_read_config o_module "$o_barnyard[configuration]" _apply once _module "$module"

    mkdir -p /var/lib/barnyard/applied

    typeset -a applied diffs

    if [[ "$o_barnyard[stage]" == production ]]; then
        case "$o_module[_apply]" in
            once )
                if [[ -e "/var/lib/barnyard/applied/$module" ]]; then
                    log module="$module" "already applied module %s" "$module"
                    return 0
                fi
                ;;
            diff | cron )
                if [[ -e "/var/lib/barnyard/applied/$module" ]]; then
                    read -r -A applied < "/var/lib/barnyard/applied/$module"
                    if [[ "$applied[1]" = "$o_barnyard[checkout]" ]]; then
                        log module="$module" "already applied module %s" "$module"
                        return 0
                    fi
                    barnyard_get_array o_module _diff diffs
                    diffs+=("machines/$o_barnyard[hostname]/$module")
                    if git -C "$o_registers[barnyard]" diff --quiet "$applied[1]" "$o_barnyard[checkout]" -- "${diffs[@]}"; then
                        log module="$module" "module %s has not changed, skipping" "$module"
                        return 0
                    fi
                    log module="$module" "module %s has changed, re-applying" "$module"
                fi
                ;;
            never )
                log module="$module" "module % run set to never, skipping" "$module"
                return 0
                ;;
        esac
    fi

    o_barnyard[module]="$module"
    export __BARNYARD_O_BARNYARD__="${(@qq)${(@kv)o_barnyard}}"
    export __BARNYARD_O_MODULE__="${(@qq)${(@kv)o_module}}"
    zsh "$BARNYARD_TEMP/run" "$SCRIPT_DIR/barnyard" "${o_barnyard[barnyard]}/modules/$o_module[_module]/apply.zsh"
    local code=$?
    [[ $code -ne 0 ]] && abend 'module %s exited %d' "${module}" $code

    if [[ "$o_barnyard[stage]" == production ]]; then
        log module="$module" "marking module %s as applied" "$module"
        git -C "$o_registers[barnyard]" log -n 1 --format='%H %at' "$o_barnyard[checkout]" > "/var/lib/barnyard/applied/$module"
    fi
}

barnyard_loop_modules() {
    mkdir -p "/var/lib/barnyard/sha1"

    barnyard_clone_directory

    barnyard_clone configure

    local barnyard="$BARNYARD_TEMP/configure"

    declare -A ordered o_module
    declare -a unordered
    local configuration
    for module in "$@"; do
        configuration="machines/$o_barnyard[hostname]/$module"
        [[ -e "$barnyard/$configuration" ]] || abend 'no configuration for module %s' "$module"
        declare -A o_module
        barnyard_read_config o_module "$barnyard/$configuration" _apply once
        if [[ "$o_module[_order]" ]]; then
            ordered[$module]="$o_module[_order]"
        else
            unordered+=("$module")
        fi
    done

    declare -a in_order
    in_order=(${(f)"$(sort -k1,2 <(for module order in "${(@kv)ordered}"; do echo "$order $module"; done) | cut -d' ' -f2)"})
    in_order+=("${unordered[@]}")

    log info modules="${(j: :)in_order[@]}" 'running modules in order' "${(j: :)in_order[@]}"

    for module in "${in_order[@]}"; do barnyard_run "$module"; done
}

barnyard_configure() {
    local next=${1:-}

    if [[ ! -e /etc/barnyard/config ]]; then
        abend 'barnyard not installed'
    fi

    typeset -A o_barnyard
    barnyard_read_config o_barnyard /etc/barnyard/config hostname "$(hostname --long)"
    o_barnyard[hostname]=$(hostname --long)
    typeset -A o_registers
    if [[ -z "$o_develop" ]]; then
        o_barnyard[stage]=production

        export GNUPGHOME=/etc/barnyard/gnupg
        export GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes -o UserKnownHostsFile=/etc/barnyard/known_hosts'

        o_registers[barnyard]=/var/lib/barnyard/repository

        if [[ -e "/var/lib/barnyard/sha1/$o_barnyard[hostname]" ]]; then
            o_barnyard[checkout]=$(<"/var/lib/barnyard/sha1/$o_barnyard[hostname]")
        fi
    else
        [[ -n "$SUDO_USER" ]] || abend 'must run through sudo'
        [[ -e "$o_registers[barnyard]" ]] || abend 'no barnyard at path %s' "${o_barnyard[barnyard]:q}"

        local barnyard_user
        barnyard_user=$(stat -c '%U' "${o_registers[barnyard]}/.git/index") || abend 'not a git repo %s' "$o_registers[barnyard]"

        [[ "$barnyard_user" == $SUDO_USER ]] || abend 'sudo user %s does not own %s' "$SUDO_USER" "${o_barnyard[barnyard]:q}"

        o_barnyard[stage]=development
        o_registers[barnyard]=$(readlink -f "$o_develop")
    fi

    $next "$@"
}

_barnyard_command_apply() {
    declare -a o_modules=( "$@" )

    if [[ -n "$o_version[1]" ]]; then
        [[ "$o_version[1]" == "$VERSION" ]] || abend "local=$o_version[1]" remote=$VERSION 'version mismatch, please run update'
    fi

    if [[ $o_barnyard[stage] == production ]]; then
        git -C "${o_registers[barnyard]}" checkout -q "${o_barnyard[branch]}"
        git -C "${o_registers[barnyard]}" pull -q origin "$branch"

        # We also include the date stamp so that we don't apply a commit that
        # got out of order due to a rebase or merge. Barnyards really ought to
        # be linear and automated, though.

        local sha1
        typeset -a current
        if [[ -n "$o_barnyard[checkout]" ]]; then
            read -r -A current <<< "$(git -C ${o_registers[barnyard]} log -n 1 --format='%H %at' "$o_barnyard[checkout]")"
        fi

        if [[ "${#current[@]}" -eq 0 ]]; then
            while read -r line; do
                read -r -A fields <<< "$line"
                if [[ "${fields[3]}" == G ]]; then
                    checkout=("${fields[@]}")
                    break
                fi
            done < <(git -C "${o_registers[barnyard]}" log --format='%H %at %G?')
        else
            while read -r line; do
                IFS=' ' read -A fields <<< "$line"
                if [[ "${fields[3]}" == G && ${fields[2]} -gt ${current[2]} ]]; then
                    checkout=("${fields[@]}")
                    break
                fi
                if [[ "${fields[1]}" == "${current[1]}" ]]; then
                    break
                fi
            done < <(git -C "${o_registers[barnyard]}" log --format='%H %at %G?')
        fi

        # https://stackoverflow.com/a/21941473
        if [[ "${#checkout[@]}" -ne 0 ]]; then
            o_barnyard[checkout]="${checkout[1]}"
            o_barnyard[stage]=production

            local list="$(ls "${o_registers[barnyard]}/machines/${o_barnyard[hostname]}")"
            declare -a modules=("${(@f)list}")

            barnyard_loop_modules "${modules[@]}"

            echo "${checkout[1]}" > "/var/lib/barnyard/sha1/${o_barnyard[hostname]}"
        fi
    else
        barnyard_loop_modules "${o_modules[@]}"
    fi
}

barnyard_command_apply() {
    eval "$(barnyard_parse_arguments apply v,version: d,develop: h,help -- "$@")"
    barnyard_configure _barnyard_command_apply "$@"
}

# Could argue that the repository should never change, but it comes from outside
# and so yes, it could change. You might want to rename your repository, why
# not? It's not immutable like the age or gpg key.

barnyard_command_clone() {
    eval "$(barnyard_parse_arguments clone "h,help" -- "$@")"

    (( $# )) || abend 'a git repository url is required'
    local repository=${1:-}

    [[ -e /etc/barnyard/id_barnyard ]] || abend 'no barnyard ssh key'

    rm -rf /var/lib/barnyard/repository

    export GIT_SSH_COMMAND='ssh -i /etc/barnyard/id_barnyard -o IdentitiesOnly=yes -o UserKnownHostsFile=/etc/barnyard/known_hosts'

    git clone -q "${repository%#*}" /var/lib/barnyard/repository || abend 'unable to clone repository %s' "$repository"

    local branch="${repository##*#}"
    if [[ -z "$branch" ]]; then
        branch=$(git rev-parse --abbrev-ref HEAD) || abend 'unable to determin branch for %s' "$repository"
    else
        git -C /var/lib/barnyard/repository checkout  "$branch" || abend 'unable to checkout branch %s' "$branch"
    fi

    print -R "branch=$branch" > /etc/barnyard/config
}

barnyard_command_commit() {
    eval "$(barnyard_parse_arguments apply h,help -- "$@")"
    tar -C /var/lib/barnyard/commit -czf - * | base64
}

# Here we add a gpg key. We also need a function to remove a key. We could use
# a Barnyard module to remove a key, but then the user has to have one, write
# one and if a key was compromised they'd want to remove it without running
# Barnyard, because Barnyard could not be trusted until the key was revoked.

barnyard_command_gpg_import() {
    eval "$(barnyard_parse_arguments gpg_import "h,help" -- "$@")"

    (( $EUID == 0 )) || abend 'must be run as root'

    (( $# )) || abend 'a file name is required'

    export GNUPGHOME=/etc/barnyard/gnupg

    local filename=${1:-} gpg_key
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi
    gpg_key=$(< "$filename") || abend 'unable to read gpg key'

    local fingerprint=$( \
        print -R "$gpg_key" | \
            gpg --with-colons --import-options show-only --import --fingerprint 2>/dev/null | \
            awk -F: '/^fpr/ { print $10; exit }' \
    )

    gpg --import <(print -R "$gpg_key") > /dev/null 2>&1 || abend 'unable to import key'
    gpg --batch --yes --sign-key "$fingerprint" > /dev/null 2>&1 || abend 'unable to sign key'
    gpg --list-keys
}

barnyard_command_gpg() {
    eval "$(barnyard_parse_arguments gpg "h,help" -- "$@")"
    barnyard_next_command gpg_ "$@"
}

# We could transfer this age encrypted, but we assume it is comming from
# `barnctl` over SSH or at the very least from a file on the filesystem of the
# host machine.

barnyard_command_ssh_known-hosts() {
    eval "$(barnyard_parse_arguments ssh_known-hosts "h,help" -- "$@")"

    (( $EUID == 0 )) || abend 'must be run as root'

    (( $# )) || abend 'a file name is required'

    local filename=${1:-} gpg_key
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi

    rm -f /etc/barnyard/id_barnyard

    cat "$filename" > /etc/barnyard/known_hosts

    cat /etc/barnyard/known_hosts
}

barnyard_command_ssh_private-key() {
    eval "$(barnyard_parse_arguments ssh_private-key "h,help" -- "$@")"

    (( $EUID == 0 )) || abend 'must be run as root'

    (( $# )) || abend 'a file name is required'

    local filename=${1:-} gpg_key
    if [[ "$filename" = - ]]; then
        filename=/dev/stdin
    fi

    rm -f /etc/barnyard/id_barnyard

    umask 077
    cat "$filename" > /etc/barnyard/id_barnyard

    ssh-keygen -lf /etc/barnyard/id_barnyard
}

barnyard_command_ssh() {
    eval "$(barnyard_parse_arguments ssh "h,help" -- "$@")"
    barnyard_next_command ssh_ "$@"
}

_barnyard_command_status() {
    declare -A o_module

    if ! (( $# )); then
        if [[ -z "${o_barnyard[checkout]}" ]]; then
            log 'barnyard not yet applied'
        else
            log 'barnyard applied %s' "${o_barnyard[checkout]}"
        fi
        return 0
    fi

    [[ -z "$o_barnyard[checkout]" ]] && abend 'barnyard not yet applied'

    barnyard_clone_directory

    while (( $# )); do
        o_module[module]="$1"
        o_module[_module]="$1"
        shift

        barnyard_clone "runs/$o_module[module]"

        o_barnyard[barnyard]="$BARNYARD_TEMP/runs/$o_module[module]"
        zsh "$BARNYARD_TEMP/run" "$SCRIPT_DIR/barnyard" "${o_barnyard[barnyard]}/modules/$o_module[_module]/status.zsh"
        echo here && exit 1
    done
}

barnyard_command_status() {
    eval "$(barnyard_parse_arguments status "d,develop:" "h,help" -- "$@")"
    barnyard_configure _barnyard_command_status "$@"
}

barnyard_command_version() {
    eval "$(barnyard_parse_arguments version "h,help" -- "$@")"
    print -R "$VERSION"
}

root() {
    eval "$(barnyard_parse_arguments root h,help -- "$@")"
    barnyard_next_command "" "$@"
}

__barnyard_priorities root "$@"

exit

___ barnyard_run ___
source <(awk '/^___ barnyard_common ___/{flag=1;next}/^___/{flag=0}flag' "$1")
shift

main() {
    unset -f main __barnyard_priorities
    typeset -A o_barnyard=( ${(@Q)${(@z)__BARNYARD_O_BARNYARD__}} ) o_module=( ${(@Q)${(@z)__BARNYARD_O_MODULE__}} )
    unset __BARNYARD_O_BARNYARD__ __BARNYARD_O_MODULE__
    . "$1"
}

__barnyard_priorities main "$@"
___
